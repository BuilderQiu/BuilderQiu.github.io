{"meta":{"title":"一本正经的扯淡","subtitle":"U Still Don't Know","description":null,"author":"BuilderQiu","url":"http://builderqiu.com"},"pages":[{"title":"一本正经的没找到 | 404","date":"2016-12-25T08:29:45.376Z","updated":"2016-12-25T08:29:45.376Z","comments":true,"path":"404.html","permalink":"http://builderqiu.com/404.html","excerpt":"","text":"一本正经的没找到"},{"title":"categories","date":"2016-12-25T06:33:37.000Z","updated":"2016-12-25T06:34:22.437Z","comments":false,"path":"categories/index.html","permalink":"http://builderqiu.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-12-25T06:33:29.000Z","updated":"2016-12-25T06:34:11.149Z","comments":false,"path":"tags/index.html","permalink":"http://builderqiu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Bridge Method (桥接方法)","slug":"BridgeMethod","date":"2015-03-17T16:00:00.000Z","updated":"2016-12-25T08:26:58.887Z","comments":true,"path":"2015/03/BridgeMethod.html","link":"","permalink":"http://builderqiu.com/2015/03/BridgeMethod.html","excerpt":"原文地址 Bridge Method直译过来就是桥接方法。从字面意思可以很容易的理解出这个方法是在连接两个东西。那到底是在连接什么呢？废话少说，上代码： 1234567891011121314151617181920212223242526272829303132abstract class A&lt;T&gt; &#123; abstract T get(T t);&#125;class B extends A&lt;String&gt; &#123; @Override String get(String s) &#123; return \"\"; &#125;&#125;public class TestBridge &#123; public static void main(String[] args) &#123; Class&lt;B&gt; clazz = B.class; Method[] methods = clazz.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; System.out.println(getMethodInfo(m) + \" is Bridge Method? \" + m.isBridge()); &#125; &#125; public static String getMethodInfo(Method m)&#123; StringBuilder sb = new StringBuilder(); sb.append(m.getReturnType()).append(\" \"); sb.append(m.getName()); Class[]params = m.getParameterTypes(); for (int i = 0; i &lt; params.length; i++) &#123; sb.append(params[i].getName()).append(\" \"); &#125; return sb.toString(); &#125;&#125;","text":"原文地址 Bridge Method直译过来就是桥接方法。从字面意思可以很容易的理解出这个方法是在连接两个东西。那到底是在连接什么呢？废话少说，上代码： 1234567891011121314151617181920212223242526272829303132abstract class A&lt;T&gt; &#123; abstract T get(T t);&#125;class B extends A&lt;String&gt; &#123; @Override String get(String s) &#123; return \"\"; &#125;&#125;public class TestBridge &#123; public static void main(String[] args) &#123; Class&lt;B&gt; clazz = B.class; Method[] methods = clazz.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; System.out.println(getMethodInfo(m) + \" is Bridge Method? \" + m.isBridge()); &#125; &#125; public static String getMethodInfo(Method m)&#123; StringBuilder sb = new StringBuilder(); sb.append(m.getReturnType()).append(\" \"); sb.append(m.getName()); Class[]params = m.getParameterTypes(); for (int i = 0; i &lt; params.length; i++) &#123; sb.append(params[i].getName()).append(\" \"); &#125; return sb.toString(); &#125;&#125; 运行上面的代码，可以看到输出结果如下：[class java.lang.String get] is Bridge Method? false[class java.lang.Object get] is Bridge Method? true 或许你现在诧异了，怎么B类中只定义了一个方法，现在怎么出现了两个呢？而且返回类型和参数类型还不同。话说这个是java5中的泛型所带来的结果了。针对上面的这段代码分析下：在java5之前，你可以往一个集合里扔任何你想扔的对象。往集合中放对象的人很爽了。但是从集合中去对象的人就头大了。你不知道你下个取到的对象将会是什么类型的。不知道转成什么类型，你也就只能使用所有Object的方法了，这样就毫无意义了。所以在java5中提供了泛型这一新特性。程序员在写代码的时候可以指定集合可以存放对象的类型。然后将这些类型检查的事情交给编译器去做，减少了程序员的工作。上面代码中&lt;&gt;中的T和String就是指定类的参数类型。T代表一种泛型，告诉编译器，一旦有类指定了T这个参数的实际类，那么get方法返回的类型也必须为同一个类（当然也可以是这个类的子类；这个也是java5中的协变式返回新特性），如果不是，就必须报错提示；将原来的运行时可能出现的错误提前到编译期了。那么，假设你是java5编译器的设计者，你会如何来设计让编译器能实现这个特性，同时能保证编译出来的字节码可以在老版本的jdk中运行呢？java5编译器中作了个很巧妙的设计——桥接方法。 下面来说说java5编译器是如何来编译上面的代码： 123abstract class A&lt;T&gt; &#123; abstract T get(T t);&#125; 对于A类，编译器看到&lt;&gt;中指定的T参数后，会用Object把类中的其他T参数替换。因为在jdk中根本就不存在T这个类嘛。替换后就成了下面这样子。 123abstract class A &#123; abstract Object get(Object obj); &#125; 上面这个过程称为类型擦除。对于B类，它继承了A类，指定了T参数为String。如果还按照以前那么编译，那编译的类就是： 12345class B extends A &#123; String get(String s) &#123; return \"\"; &#125; &#125; 这样在运行时肯定会报错，因为B继承了A，而A又是asbtract类，B还没overriding A中Object get()方法。如何解决这个错误呢？java5编译器在编译的时候做了些手脚。当编译器发现你指定了类型参数，便会在编译的字节码中添加一个桥接方法。这个可以查看B的反编译代码就知道了。 12345678910class B extends A &#123; //编译器添加的方法 Object get(Object s) &#123; return (Object) get((String) s); &#125; String get(String s) &#123; return \"\"; &#125; &#125; 那么编译器会在什么情况下添加桥接方法呢？这个就不细说了，感兴趣的可以自己尝试。下面再说说协变式返回，什么是协变式返回呢？先可以对比下java1.4和java5中对于重写的定义： In Java 1.4, and earlier, one method can override another if the signatures match exactly.In Java 5, a method can override another if the arguments match exactly but the return type of the overriding method, if it is a subtype of the return type of the other method. 也就是说，对于重写的判断放宽了条件，子类中方法返回的类型是父类中方法返回类型的子类也是重写，听起来有点绕，看下面这段代码： 123456789class A&#123; Father get()&#123;&#125; &#125; class B extends A&#123; @Override Son get()&#123;&#125; &#125; class Father&#123;&#125; class Sun extends Father&#123;&#125; 也就是B中的get()方法返回Son类也是重载。如何实现的呢？同样是使用桥接方法。 关于桥接方法更多的可以参考JLSCreate Frame, Synchronize, Transfer Control","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://builderqiu.com/tags/Java/"}]},{"title":"基于Redis与ActiveMQ、Spring的简单聊天室系统设计","slug":"ChatRoomBaseOnRedis","date":"2014-09-14T16:00:00.000Z","updated":"2016-12-25T08:22:36.291Z","comments":true,"path":"2014/09/ChatRoomBaseOnRedis.html","link":"","permalink":"http://builderqiu.com/2014/09/ChatRoomBaseOnRedis.html","excerpt":"其他相关 基于Redis的在线用户列表解决方案 基于Spring的异步系统实现方案 系统概述1.系统功能用于实现以页面为房间基数的聊天室系统，以达到访问同一页面的用户可以进行伪实时通讯交流的功能，之所以是伪实时通讯是因为实现技术基于WebAjax轮询完成，而非Socket之类真真双向通讯。","text":"其他相关 基于Redis的在线用户列表解决方案 基于Spring的异步系统实现方案 系统概述1.系统功能用于实现以页面为房间基数的聊天室系统，以达到访问同一页面的用户可以进行伪实时通讯交流的功能，之所以是伪实时通讯是因为实现技术基于WebAjax轮询完成，而非Socket之类真真双向通讯。 2.组件技术 Redis （Published &amp; Subscribe） ActiveMQ （MessageQueue） Spring Ajax 3.大体流程1.用户发送消息： 用户在Web前端发送消息（一般的表单）之后，后台收到消息，记录并向MessageQueue里添加一条待Published的消息，返回Web前端发送成功的状态。 2.系统发送消息：Spring Listener 后台监听MessageQueue，读取并处理消息，若为实时通讯的消息，则将MessagePublished到Redis中。 3.系统读取消息：系统中ChatListener Subscribe From Redis，从Redis中取出订阅的消息并加入本地缓存。 4.用户读取消息：Web前端定时发起Ajax请求新的数据，系统判断缓存中是否有新的消息，若有则返回所有新消息，若没有则Hold住连接，线程休眠，每隔一定时间去访问缓存查看是否有新消息，有则返回，达到一定次数还没有新消息则返回无新消息的状态。 系统大体结构图1234567891011121314151617181920212223242526272829303132333435363738394041 Server +-----------------------------------------------------------------------+ | | | +----------------------+ +-------------------------------+ | | | Room | | RoomManager | | | +----------------------+ +-------------------------------+ | +------------+ | | | | | | | | getMessage| | reads:HashMap +----------+ rooms:HashMap | | | Customer | &lt;---------+ | | | | | | | | | getAllMessage(sid) | | refresh(channelId) | | +------------+ | | | | | | | | addMessage(V) | | pushMessage(channelId,message)| | | | | | | | | +----------------------+ +-------------------------------+ | | | | ^ | | | Push | | | | | | | +----------------------+ +-------------------------------+ | | | MessageListener | | ChatListener | | | +----------------------+ +-------------------------------+ | | | | +-----+ | | | | onPMessage() | | | | | | | | | | | | | +----------------------+ | +-------------------------------+ | | | | | ^ | ^ | | | | | | +-----------------------------------------------------------------------+ | | | | Sub | | Listener (ConsumerMessage) | |Publish | | | | | +----------------------+ | +-------------------------------+ | | | | | | Redis | &lt;--+ | ActiveMQ | | | | | +----------------------+ +-------------------------------+ 代码实现ChatRoom房间类，每个房间内持有该房间内所有的用户的已读消息位，同时提供所有用户获取新消息的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import jodd.cache.Cache;import jodd.cache.FIFOCache;public class ChatRoom&lt;V&gt; &#123; private Long nowMessageId = 0L;//当前缓存最新消息的ID private String channelId;//房间号 private Map&lt;String,Long&gt; reads = new HashMap&lt;String,Long&gt;(); private Cache&lt;String,V&gt; cache = new FIFOCache&lt;String,V&gt;(50);//最多保存50条未读信息 public ChatRoom(String channelId) &#123; super(); this.channelId = channelId; &#125; public void addMessage(V message)&#123; cache.put(channelId+\":\"+nowMessageId, message); nowMessageId += 1; &#125; //根据用户id取出当前未读消息 public List&lt;V&gt; getAllMessage(String sid)&#123;//Web项目，该处用的是SessionId Long messageId = reads.get(sid); if(messageId == null)&#123; messageId = nowMessageId; reads.put(sid, messageId); &#125; if(messageId &gt;= nowMessageId)&#123; return Collections.emptyList(); &#125; List&lt;V&gt; message = new ArrayList&lt;V&gt;(); while(messageId &lt; nowMessageId)&#123; V msg = cache.get(channelId+\":\"+messageId); if(msg != null)&#123; message.add(msg); &#125; messageId ++; &#125; reads.put(sid, messageId);//更新已读 return message; &#125; public String getChannelId()&#123; return this.channelId; &#125; public long getNowMessageId()&#123; return this.nowMessageId; &#125;&#125; ChatRoomManager房间管理器，负责管理所有ChatRoom，消息发送等，清除无用ChatRoom暂未实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.HashMap;import java.util.Map;import redis.clients.jedis.Jedis;import com.xxx.core.redis.RedisPoolUtils;public class ChatRoomManager &#123; public static final ChatRoomManager instance = new ChatRoomManager(); public static final String SUB = \"video:chat:\";//用于在Redis中订阅的订阅号前缀 private Map&lt;String,ChatRoom&gt; rooms = new HashMap&lt;String, ChatRoom&gt;(); private ChatRoomManager()&#123;&#125; public static ChatRoomManager getInstance()&#123; return instance; &#125; public &lt;V&gt; ChatRoom&lt;V&gt; getChatRoom(String roomId)&#123; ChatRoom room = rooms.get(roomId); if(room == null)&#123; synchronized(this)&#123; room = rooms.get(roomId); if(room == null)&#123; room = new ChatRoom&lt;String&gt;(roomId); rooms.put(roomId, room); &#125; &#125; &#125; return room; &#125; public &lt;V&gt; ChatRoom&lt;V&gt; getChatRoomAndRefresh(String roomId,String uid)&#123; ChatRoom room = rooms.get(roomId); if(room == null)&#123; synchronized(this)&#123; room = rooms.get(roomId); if(room == null)&#123; room = new ChatRoom&lt;String&gt;(roomId); &#125; &#125; &#125; refresh(roomId,uid);//刷新房间内用户在线列表 return room; &#125; public ChatRoom removeRoom(String roomId)&#123; return rooms.remove(roomId); &#125; public boolean containsRoom(String roomId)&#123; return rooms.containsKey(roomId); &#125; public &lt;V&gt; ChatRoom&lt;V&gt; addRoom(ChatRoom&lt;V&gt; room)&#123; return rooms.put(room.getChannelId(), room); &#125; //发送消息到指定Channel public Long pushMessage(String channel,String message)&#123; Jedis jedis = RedisPoolUtils.getJedis(); Long count = jedis.publish(channel, message); RedisPoolUtils.release(jedis); return count; &#125; public void refresh(String roomId,String uid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); jedis.setex(\"chat:room:\"+roomId+\":\"+uid, 30, \"1\"); RedisPoolUtils.release(jedis); &#125;&#125; MessageListener订阅Redis服务，监听消息并做分发处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.JedisPubSub;public class MessageListener extends JedisPubSub &#123; private static final Logger log = LoggerFactory.getLogger(MessageListener.class); private ChatRoomManager manager = ChatRoomManager.getInstance(); @Override public void onMessage(String chanel, String message) &#123; log.debug(\"onMessage\"); &#125; @Override public void onPMessage(String pattern, String channel, String message) &#123; log.debug(\"onPMessage[pattern:\"+pattern+\",channel:\"+channel+\",message:\"+message+\"]\"); //用来处理psubscribe的消息,Dispatcher Message ChatRoom&lt;String&gt; room = manager.getChatRoom(channel); room.addMessage(message); &#125; @Override public void onPSubscribe(String arg0, int arg1) &#123; log.debug(\"onPSubscribe\"); &#125; @Override public void onPUnsubscribe(String arg0, int arg1) &#123; log.debug(\"onPUnsubscribe\"); &#125; @Override public void onSubscribe(String arg0, int arg1) &#123; log.debug(\"onSubscribe\"); &#125; @Override public void onUnsubscribe(String arg0, int arg1) &#123; log.debug(\"onUnsubscribe\"); &#125;&#125; ChatListener异步监听类，有新消息就Publish到Redis中 12345678910111213141516171819202122232425262728293031323334353637import javax.jms.Message;import javax.jms.MessageListener;import org.apache.activemq.command.ActiveMQMapMessage;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import redis.clients.jedis.Jedis;import com.xxx.core.redis.RedisPoolUtils;@Componentpublic class ChatListener implements MessageListener &#123; private static Logger log = LoggerFactory.getLogger(ChatListener.class); private Jedis client = RedisPoolUtils.getJedis(); @Override public void onMessage(Message message) &#123; ActiveMQMapMessage msg = (ActiveMQMapMessage) message; try &#123; if(client == null || !client.isConnected())&#123; client = RedisPoolUtils.getJedis(); &#125; String roomId = msg.getString(\"roomId\"); String content = msg.getString(\"content\"); client.publish(roomId, content); &#125; catch (Exception e) &#123; log.error(\"异步实时交互信息发送异常\", e); &#125; &#125;&#125; 发送异步聊天消息的方法： 1234567891011121314151617181920212223public static boolean sendChatComment(String roomId,Map content)&#123; try&#123; final ActiveMQMapMessage message = new ActiveMQMapMessage(); JSONObject obj = JSONObject.fromObject(content); message.setString(\"roomId\", ChatRoomManager.SUB+ roomId); message.setString(\"content\", obj.toString()); jmsTemplate.send(chatDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return message; &#125; &#125;); &#125;catch (Exception e) &#123; log.error(\"实时交互信息发送失败！\",e); return false; &#125; return true;&#125; 消息监听系统启动时，单启线程监听消息： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Date;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import redis.clients.jedis.Jedis;import com.xxx.common.util.DateUtils;import com.xxx.core.chat.ChatRoomManager;import com.xxx.core.chat.MessageListener;import com.xxx.core.redis.RedisPoolUtils;/** * 系统启动时监听通讯 */@Componentpublic class MessageChatBootstrap implements InitializingBean &#123; private Logger log = LoggerFactory.getLogger(MessageChatBootstrap.class); @Override public void afterPropertiesSet() throws Exception &#123; log.info(\"ChatSystem Starting... At \"+DateUtils.formatDateTime(new Date(), \"yyyy-MM-dd HH:mm:ss\")); try&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Jedis jedis = RedisPoolUtils.getJedis(); jedis.psubscribe(new MessageListener(), ChatRoomManager.SUB+\"*\");//订阅所有 video:chat:* &#125; &#125;).start(); &#125;catch (Exception e) &#123; log.error(\"即时聊天服务运行出错\"); e.printStackTrace(); &#125; log.info(\"ChatSystem Starting finished! At \"+DateUtils.formatDateTime(new Date(), \"yyyy-MM-dd HH:mm:ss\")); &#125;&#125; 前端访问接口(SpringMVC)前端Ajax长连接轮询接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.Iterator;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.xxx.common.util.StringUtil;import com.xxx.core.chat.ChatRoom;import com.xxx.core.chat.ChatRoomManager;@Controllerpublic class ChatController &#123; private static final int MAX_WAIT = 10; private static final Logger log = LoggerFactory.getLogger(ChatController.class); @RequestMapping(value=\"/chat/refresh\",produces=\"text/html;charset=utf-8\") @ResponseBody public String refresh(String roomId,HttpServletRequest request)&#123; log.debug(\"roomId:\"+roomId); ChatRoom&lt;String&gt; room = ChatRoomManager.getInstance().getChatRoom(ChatRoomManager.SUB+roomId); String sid = request.getSession().getId(); List&lt;String&gt; messages = room.getAllMessage(sid); if(messages.size() == 0)&#123; int passTime = 0; try &#123; while(passTime &lt; MAX_WAIT &amp;&amp; messages.size() == 0)&#123; //等待10秒,Hold住请求 Thread.sleep(2000); passTime += 2; messages = room.getAllMessage(sid); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; fileterSelf(messages,request.getSession()); String result =wrapMessage(messages); log.debug(\"result:\"+ result); return result; &#125; /** * * @Title: fileterSelf * @Description: 过滤掉自己发的消息 * @param @param messages * @return void * @throws */ private void fileterSelf(List&lt;String&gt; messages,HttpSession session)&#123; String uid = (String) session.getAttribute(\"clientUserId\"); if(StringUtil.isNotBlank(uid)&amp;&amp;messages != null&amp;&amp;messages.size()&gt;0)&#123; Iterator&lt;String&gt; iterator = messages.iterator(); while(iterator.hasNext())&#123; String contetnt = iterator.next(); if(contetnt.contains(uid))&#123; iterator.remove(); &#125; &#125; &#125; &#125; private String wrapMessage(List&lt;String&gt; message)&#123; JSONArray array = JSONArray.fromObject(message); return array.toString(); &#125;&#125; 基于JQuery的JS模块实现123456789101112131415161718192021222324252627282930313233343536373839404142(function($)&#123; $.Chat = (function()&#123; var config = &#123;roomId:&apos;room1&apos;,url:&apos;/chat/refresh.html&apos;&#125;; function init(conf)&#123; config = $.extend(config,conf); &#125;; function start()&#123; $.ajax(&#123; type: &apos;post&apos;, url: config.url, data: &#123; roomId: config.roomId &#125;, dataType: &apos;json&apos;, success: function(response) &#123; $.Chat.execute(response); if(response.length &gt; 0)&#123; setTimeout( start,1000); &#125;else&#123; setTimeout( start,6000); &#125; &#125;, error: function(e) &#123; console.log(e); &#125;, timeout: 20000 &#125;); &#125; function execute(data)&#123; console.log(data); &#125; return &#123; start:start, init:init, execute:execute &#125;; &#125;)($);&#125;)(jQuery); 使用方法： 12$.Chat.init(&#123;roomId:&apos;xxxx&apos;&#125;); //url根据实际情况而定,ChatRoomManager.SUB + roomId即后台Redis发布订阅需要的ChannelID$.Chat.start(); Q &amp; A:既然消息要缓存在服务器本地，为什么还要先发送到Redis，然后再从Redis中取回本地？这样便使得消息可以分布式，以实现在分布式的环境下，客户端从每台服务器都可以获得订阅的消息 目前在自己的项目中基本能满足需求，且可以很容易的进行分布式，很容易扩展至多终端。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://builderqiu.com/tags/Spring/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://builderqiu.com/tags/ActiveMQ/"},{"name":"Redis","slug":"Redis","permalink":"http://builderqiu.com/tags/Redis/"}]},{"title":"LinuxShell基础","slug":"ShellDetails","date":"2014-09-09T16:00:00.000Z","updated":"2016-12-24T14:32:12.119Z","comments":true,"path":"2014/09/ShellDetails.html","link":"","permalink":"http://builderqiu.com/2014/09/ShellDetails.html","excerpt":"什么是ShellShell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。 它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Unix/Linux系统的关键。 可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。 注意：单独地学习 Shell 是没有意义的，请先了解 Unix/Linux 基础。 Shell有两种执行命令的方式：交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。 Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。 Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是 root，那就不同了，只要敲几个字母，就可能导致灾难性后果。","text":"什么是ShellShell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。 它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Unix/Linux系统的关键。 可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。 注意：单独地学习 Shell 是没有意义的，请先了解 Unix/Linux 基础。 Shell有两种执行命令的方式：交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。 Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。 Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是 root，那就不同了，只要敲几个字母，就可能导致灾难性后果。 几种常见的ShellUnix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。 bashbash是Linux标准默认的shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain Shell的缩写，内部命令一共有40个。 Linux使用它作为默认的shell是因为它有诸如以下的特色：可以使用类似DOS下面的doskey的功能，用方向键查阅和快速输入并修改命令。自动通过查找匹配的方式给出以某字符串开头的命令。包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。 shsh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。 ashash shell 是由Kenneth Almquist编写的，Linux中占用系统资源最少的一个小shell，它只包含24个内部命令，因而使用起来很不方便。 cshcsh 是Linux比较大的内核，它由以William Joy为代表的共计47位作者编成，共有52个内部命令。该shell其实是指向/bin/tcsh这样的一个shell，也就是说，csh其实就是tcsh。 kshksh 是Korn shell的缩写，由Eric Gisin编写，共有42条内部命令。该shell最大的优点是几乎和商业发行版的ksh完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。 注意：bash是 Bourne Again Shell 的缩写，是linux标准的默认shell ，它基于Bourne shell，吸收了C shell和Korn shell的一些特性。bash完全兼容sh，也就是说，用sh写的脚本可以不加修改的在bash中执行。 特性 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 特殊变量列表 $* 和 $@ 的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。 但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。 退出状态$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。 退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。 不过，也有一些命令返回其他值，表示不同类型的错误。 下面的转义字符都可以用在 echo 中： 转义字符 含义 \\\\ 反斜杠 \\a 警报，响铃 \\b 退格（删除键） \\f 换页(FF)，将当前位置移到下页开头 \\n 换行 \\r 回车 \\t 水平制表符（tab键） \\v 垂直制表符 可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。 命令替换命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。 命令替换的语法： 1`command` 注意是反引号，不是单引号，这个键位于 Esc 键下方。 变量替换变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值 可以使用的变量替换形式： 形式 说明 ${var} 变量本来的值 ${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。 ${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。 ${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。 ${var:+word} 如果变量 var 被定义，那么返回 word，但不改变 var 的值。 运算原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加： 123#!/bin/bashval=`expr 6 \\* 3`echo &quot;Total value : $val&quot; 运行脚本输出： 1Total value : 18 两点注意： 表达式和运算符之间要有空格，例如 6*3 是不对的，必须写成 6 * 3，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 算术运算符列表 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 true。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 关系运算符列表 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 布尔运算符列表 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 字符串运算符列表 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 文件测试运算符列表 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。 在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为： 1array_name=(value1 ... valuen) 例如： 1array_name=(value0 value1 value2 value3) 获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; ##判断语句 ###if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if … else 语句： if … fi 语句； if … else … fi 语句； if … elif … else … fi 语句。 1) if … else 语句 if … else 语句的语法： 1234if [ expression ]then Statement(s) to be executed if expression is truefi 2) if … else … fi 语句 if … else … fi 语句的语法： 123456if [ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi 3) if … elif … fi 语句 if … elif … fi 语句可以对多个条件进行判断，语法为： 123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi case … esac与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。 case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下： 1234567891011121314151617case 值 in模式1) command1 command2 command3 ;;模式2） command1 command2 command3 ;;*) command1 command2 command3 ;;esac case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 循环for循环for循环一般格式为： 1234567for 变量 in 列表do command1 command2 ... commandNdone 列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。 whilewhile循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234while commanddo Statement(s) to be executed if command is truedone 命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。 untiluntil 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。 until 循环格式为： 1234until commanddo Statement(s) to be executed until command is truedone command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。 函数函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。 Shell 函数的定义格式如下： 1234function_name () &#123; list of commands [ return value ]&#125; 如果你愿意，也可以在函数名前加上关键字 function： 1234function function_name () &#123; list of commands [ return value ]&#125; 函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。 Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。 如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。 调用函数只需要给出函数名，不需要加括号。 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 另外，还有几个特殊变量用来处理参数，前面已经提到： 特殊变量 说明 $# 传递给函数的参数个数。 $* 显示所有传递给函数的参数。 $@ 与$*相同，但是略有区别。 $? 函数的返回值。 重定向一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 全部可用的重定向命令列表 ###/dev/null 文件 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1$ command &gt; /dev/null 2&gt;&amp;1 包含像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。 Shell 中包含脚本可以使用： 1. filename 或 1source filename 两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。 参考至：shell","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://builderqiu.com/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"http://builderqiu.com/tags/Linux/"}]},{"title":"Ant模式通配符","slug":"SpringAntWildcards","date":"2014-09-03T16:00:00.000Z","updated":"2016-12-25T08:23:32.704Z","comments":true,"path":"2014/09/SpringAntWildcards.html","link":"","permalink":"http://builderqiu.com/2014/09/SpringAntWildcards.html","excerpt":"","text":"Spring提供了强大的Ant模式通配符匹配，从同一个路径能匹配一批资源。 Ant路径通配符支持&quot;?&quot;、&quot;*&quot;、&quot;**&quot;，注意通配符匹配不包括目录分隔符“/”。 “?”:匹配一个字符，如&quot;config?.xml&quot;可匹配&quot;config1.xml&quot;. “*”：匹配零个或多个字符串，如“com/*/config.xml”将匹配“cn/feng/config.xml”,但不匹配匹配“com/config.xml”(因为这里匹配的是字符串，如果是目录的话则可以)；而“com/config-*.xml”将匹配“com/config-dao.xml”； &quot;**&quot;：匹配路径中的零个或多个目录。如“com/**/config.xml”将匹配“com/config.xml”,也匹配“com/feng/spring/config.xml”；而“com/feng/config-**.xml”将匹配 “com/feng/config-dao.xml”，即把“**”当做两个“*”处理。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://builderqiu.com/tags/Spring/"},{"name":"通配符","slug":"通配符","permalink":"http://builderqiu.com/tags/通配符/"}]},{"title":"简单的Java缓存实现","slug":"JavaCacheSampleImpl","date":"2014-09-02T16:00:00.000Z","updated":"2016-12-25T08:22:49.866Z","comments":true,"path":"2014/09/JavaCacheSampleImpl.html","link":"","permalink":"http://builderqiu.com/2014/09/JavaCacheSampleImpl.html","excerpt":"提到缓存，不得不提就是缓存算法(淘汰算法)，常见算法有LRU、LFU和FIFO等算法，每种算法各有各的优势和缺点及适应环境。 1、LRU(Least Recently Used ，最近最少使用)算法根据数据的最近访问记录来淘汰数据，其原理是如果数据最近被访问过，将来被访问的几概率相对比较高，最常见的实现是使用一个链表保存缓存数据，详细具体算法如下： 新数据插入到链表头部； 每当缓存数据命中，则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃； 2、LFU(Least Frequently Used，最不经常使用)算法根据数据的历史访问频率来淘汰数据，其原理是如果数据过去被访问次数越多，将来被访问的几概率相对比较高。LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。具体算法如下： 新加入数据插入到队列尾部（因为引用计数为1）； 队列中的数据被访问后，引用计数增加，队列重新排序； 当需要淘汰数据时，将已经排序的列表最后的数据块删除； 3、FIFO(First In First Out ，先进先出)算法是根据先进先出原理来淘汰数据的，实现上是最简单的一种,具体算法如下： 新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动； 淘汰FIFO队列头部的数据；","text":"提到缓存，不得不提就是缓存算法(淘汰算法)，常见算法有LRU、LFU和FIFO等算法，每种算法各有各的优势和缺点及适应环境。 1、LRU(Least Recently Used ，最近最少使用)算法根据数据的最近访问记录来淘汰数据，其原理是如果数据最近被访问过，将来被访问的几概率相对比较高，最常见的实现是使用一个链表保存缓存数据，详细具体算法如下： 新数据插入到链表头部； 每当缓存数据命中，则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃； 2、LFU(Least Frequently Used，最不经常使用)算法根据数据的历史访问频率来淘汰数据，其原理是如果数据过去被访问次数越多，将来被访问的几概率相对比较高。LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。具体算法如下： 新加入数据插入到队列尾部（因为引用计数为1）； 队列中的数据被访问后，引用计数增加，队列重新排序； 当需要淘汰数据时，将已经排序的列表最后的数据块删除； 3、FIFO(First In First Out ，先进先出)算法是根据先进先出原理来淘汰数据的，实现上是最简单的一种,具体算法如下： 新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动； 淘汰FIFO队列头部的数据； 评价一个缓存算法好坏的标准主要有两个，一是命中率要高，二是算法要容易实现。当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。LFU效率要优于LRU，且能够避免周期性或者偶发性的操作导致缓存命中率下降的问题。但LFU需要记录数据的历史访问记录，一旦数据访问模式改变，LFU需要更长时间来适用新的访问模式，即：LFU存在历史数据影响将来数据的“缓存污染”效用。FIFO虽然实现很简单，但是命中率很低，实际上也很少使用这种算法。 基于现有jdk类库，我们可以很容易实现上面的缓存算法 首先定义缓存接口类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 缓存接口 * @author Wen * */public interface Cache&lt;K,V&gt; &#123; /** * 返回当前缓存的大小 * * @return */ int size(); /** * 返回默认存活时间 * * @return */ long getDefaultExpire(); /** * 向缓存添加value对象,其在缓存中生存时间为默认值 * * @param key * @param value */ void put(K key ,V value) ; /** * 向缓存添加value对象,并指定存活时间 * @param key * @param value * @param expire 过期时间 */ void put(K key ,V value , long expire ) ; /** * 查找缓存对象 * @param key * @return */ V get(K key); /** * 淘汰对象 * * @return 被删除对象大小 */ int eliminate(); /** * 缓存是否已经满 * @return */ boolean isFull(); /** * 删除缓存对象 * * @param key */ void remove(K key); /** * 清除所有缓存对象 */ void clear(); /** * 返回缓存大小 * * @return */ int getCacheSize(); /** * 缓存中是否为空 */ boolean isEmpty();&#125; 基本实现抽象类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 默认实现 */public abstract class AbstractCacheMap&lt;K,V&gt; implements Cache&lt;K,V&gt; &#123; class CacheObject&lt;K2,V2&gt; &#123; CacheObject(K2 key, V2 value, long ttl) &#123; this.key = key; this.cachedObject = value; this.ttl = ttl; this.lastAccess = System.currentTimeMillis(); &#125; final K2 key; final V2 cachedObject; long lastAccess; // 最后访问时间 long accessCount; // 访问次数 long ttl; // 对象存活时间(time-to-live) boolean isExpired() &#123; if (ttl == 0) &#123; return false; &#125; return lastAccess + ttl &lt; System.currentTimeMillis(); &#125; V2 getObject() &#123; lastAccess = System.currentTimeMillis(); accessCount++; return cachedObject; &#125; &#125; protected Map&lt;K,CacheObject&lt;K,V&gt;&gt; cacheMap; private final ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock(); private final Lock readLock = cacheLock.readLock(); private final Lock writeLock = cacheLock.writeLock(); protected int cacheSize; // 缓存大小 , 0 -&gt; 无限制 protected boolean existCustomExpire ; //是否设置默认过期时间 public int getCacheSize() &#123; return cacheSize; &#125; protected long defaultExpire; // 默认过期时间, 0 -&gt; 永不过期 public AbstractCacheMap(int cacheSize ,long defaultExpire)&#123; this.cacheSize = cacheSize ; this.defaultExpire = defaultExpire ; &#125; public long getDefaultExpire() &#123; return defaultExpire; &#125; protected boolean isNeedClearExpiredObject()&#123; return defaultExpire &gt; 0 || existCustomExpire ; &#125; public void put(K key, V value) &#123; put(key, value, defaultExpire ); &#125; public void put(K key, V value, long expire) &#123; writeLock.lock(); try &#123; CacheObject&lt;K,V&gt; co = new CacheObject&lt;K,V&gt;(key, value, expire); if (expire != 0) &#123; existCustomExpire = true; &#125; if (isFull()) &#123; eliminate() ; &#125; cacheMap.put(key, co); &#125; finally &#123; writeLock.unlock(); &#125; &#125; /** * &#123;@inheritDoc&#125; */ public V get(K key) &#123; readLock.lock(); try &#123; CacheObject&lt;K,V&gt; co = cacheMap.get(key); if (co == null) &#123; return null; &#125; if (co.isExpired() == true) &#123; cacheMap.remove(key); return null; &#125; return co.getObject(); &#125; finally &#123; readLock.unlock(); &#125; &#125; public final int eliminate() &#123; writeLock.lock(); try &#123; return eliminateCache(); &#125; finally &#123; writeLock.unlock(); &#125; &#125; /** * 淘汰对象具体实现 * * @return */ protected abstract int eliminateCache(); public boolean isFull() &#123; if (cacheSize == 0) &#123;//o -&gt; 无限制 return false; &#125; return cacheMap.size() &gt;= cacheSize; &#125; public void remove(K key) &#123; writeLock.lock(); try &#123; cacheMap.remove(key); &#125; finally &#123; writeLock.unlock(); &#125; &#125; public void clear() &#123; writeLock.lock(); try &#123; cacheMap.clear(); &#125; finally &#123; writeLock.unlock(); &#125; &#125; public int size() &#123; return cacheMap.size(); &#125; public boolean isEmpty() &#123; return size() == 0; &#125;&#125; LRU缓存实现类: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Iterator;import java.util.LinkedHashMap;import java.util.Map;/** * LRU 实现 * @author Wen * * @param &lt;K&gt; * @param &lt;V&gt; */public class LRUCache&lt;K, V&gt; extends AbstractCacheMap&lt;K, V&gt; &#123; public LRUCache(int cacheSize, long defaultExpire) &#123; super(cacheSize , defaultExpire) ; //linkedHash已经实现LRU算法 是通过双向链表来实现，当某个位置被命中，通过调整链表的指向将该位置调整到头位置，新加入的内容直接放在链表头，如此一来，最近被命中的内容就向链表头移动，需要替换时，链表最后的位置就是最近最少使用的位置 this.cacheMap = new LinkedHashMap&lt;K, CacheObject&lt;K, V&gt;&gt;( cacheSize +1 , 1f,true ) &#123; @Override protected boolean removeEldestEntry( Map.Entry&lt;K, CacheObject&lt;K, V&gt;&gt; eldest) &#123; return LRUCache.this.removeEldestEntry(eldest); &#125; &#125;; &#125; private boolean removeEldestEntry(Map.Entry&lt;K, CacheObject&lt;K, V&gt;&gt; eldest) &#123; if (cacheSize == 0) return false; return size() &gt; cacheSize; &#125; /** * 只需要实现清除过期对象就可以了,linkedHashMap已经实现LRU */ @Override protected int eliminateCache() &#123; if(!isNeedClearExpiredObject())&#123; return 0 ;&#125; Iterator&lt;CacheObject&lt;K, V&gt;&gt; iterator = cacheMap.values().iterator(); int count = 0 ; while(iterator.hasNext())&#123; CacheObject&lt;K, V&gt; cacheObject = iterator.next(); if(cacheObject.isExpired() )&#123; iterator.remove(); count++ ; &#125; &#125; return count; &#125;&#125; LFU实现类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.HashMap;import java.util.Iterator;//LFU实现public class LFUCache&lt;K,V&gt; extends AbstractCacheMap&lt;K, V&gt; &#123; public LFUCache(int cacheSize, long defaultExpire) &#123; super(cacheSize, defaultExpire); cacheMap = new HashMap&lt;K, CacheObject&lt;K,V&gt;&gt;(cacheSize+1) ; &#125; /** * 实现删除过期对象 和 删除访问次数最少的对象 * */ @Override protected int eliminateCache() &#123; Iterator&lt;CacheObject&lt;K, V&gt;&gt; iterator = cacheMap.values().iterator(); int count = 0 ; long minAccessCount = Long.MAX_VALUE ; while(iterator.hasNext())&#123; CacheObject&lt;K, V&gt; cacheObject = iterator.next(); if(cacheObject.isExpired() )&#123; iterator.remove(); count++ ; continue ; &#125;else&#123; minAccessCount = Math.min(cacheObject.accessCount , minAccessCount) ; &#125; &#125; if(count &gt; 0 ) return count ; if(minAccessCount != Long.MAX_VALUE )&#123; iterator = cacheMap.values().iterator(); while(iterator.hasNext())&#123; CacheObject&lt;K, V&gt; cacheObject = iterator.next(); cacheObject.accessCount -= minAccessCount ; if(cacheObject.accessCount &lt;= 0 )&#123; iterator.remove(); count++ ; &#125; &#125; &#125; return count; &#125;&#125; FIFO实现类: 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Iterator;import java.util.LinkedHashMap;/** * FIFO实现 * @author Wen * * @param &lt;K&gt; * @param &lt;V&gt; */public class FIFOCache&lt;K, V&gt; extends AbstractCacheMap&lt;K, V&gt; &#123; public FIFOCache(int cacheSize, long defaultExpire) &#123; super(cacheSize, defaultExpire); cacheMap = new LinkedHashMap&lt;K, CacheObject&lt;K, V&gt;&gt;(cacheSize + 1); &#125; @Override protected int eliminateCache() &#123; int count = 0; K firstKey = null; Iterator&lt;CacheObject&lt;K, V&gt;&gt; iterator = cacheMap.values().iterator(); while (iterator.hasNext()) &#123; CacheObject&lt;K, V&gt; cacheObject = iterator.next(); if (cacheObject.isExpired()) &#123; iterator.remove(); count++; &#125; else &#123; if (firstKey == null) firstKey = cacheObject.key; &#125; &#125; if (firstKey != null &amp;&amp; isFull()) &#123;//删除过期对象还是满,继续删除链表第一个 cacheMap.remove(firstKey); &#125; return count; &#125;&#125; 原文：简单的java缓存实现","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://builderqiu.com/tags/Java/"},{"name":"Cache","slug":"Cache","permalink":"http://builderqiu.com/tags/Cache/"}]},{"title":"如何构建Java Web应用的session框架","slug":"JavaWebSessionFramework","date":"2014-08-29T16:00:00.000Z","updated":"2016-12-24T14:31:55.254Z","comments":true,"path":"2014/08/JavaWebSessionFramework.html","link":"","permalink":"http://builderqiu.com/2014/08/JavaWebSessionFramework.html","excerpt":"原文地址 做web开发的朋友都知道，一个网站在发展的过程中，随着流量的不断增加，必然会遇到伸缩性的问题，虽然目前硬件的价格已经在减低，有时候可以通过垂直伸缩的方式来达到应对访问量不断增加的麻烦，但是垂直伸缩总是会遇到瓶颈，那么此时就需要水平伸缩了。当水平伸缩的时候，最重要的一点就是状态管理，而web应用的状态通产采用httpsession的管理方式，不同的web server(比如tomcat,jboss,jetty等等)都提供了对httpsession的支持，但是webserver通常采用了集群节点之间互相复制session状态的方式来进行状态管理，这样随着集群节点的增加，集群之间的复制的开销会越来越大，这从某种程度上来说也限制了应用的伸缩性。本文就简单总结一下构建一个Java web 应用的session框架的思路是什么样子。","text":"原文地址 做web开发的朋友都知道，一个网站在发展的过程中，随着流量的不断增加，必然会遇到伸缩性的问题，虽然目前硬件的价格已经在减低，有时候可以通过垂直伸缩的方式来达到应对访问量不断增加的麻烦，但是垂直伸缩总是会遇到瓶颈，那么此时就需要水平伸缩了。当水平伸缩的时候，最重要的一点就是状态管理，而web应用的状态通产采用httpsession的管理方式，不同的web server(比如tomcat,jboss,jetty等等)都提供了对httpsession的支持，但是webserver通常采用了集群节点之间互相复制session状态的方式来进行状态管理，这样随着集群节点的增加，集群之间的复制的开销会越来越大，这从某种程度上来说也限制了应用的伸缩性。本文就简单总结一下构建一个Java web 应用的session框架的思路是什么样子。本文将会从session状态的存储，session信息的管理，安全性问题，以及如何与Servlet Container结合。 在开始之前，我们首先需要明确一点这里所说的session的概念是广义的，不仅仅是指httpSession。 Session状态存储咋们首先来谈谈Session状态的存储。我们先来看看平常的日常工作当中，我们是怎么存储Session状态信息的。我们举个例子来说，比如用户的浏览历史，我们可能会将其保存在http cookie中，另外比如用户是否登陆的信息，我们可能选择保存在httpsession之中。上面说了存储到httpsession中会受限于web server的实现，伸缩性有限。那么我们在构建session框架的时候，可以考虑用一个分布式的缓存服务器来存储session状态，比如可以利用memecached服务器来进行存储。 另外这里面也涉及到另外一个问题，状态的跟踪问题，我们如何区分不同的用户的session信息？这里其实就需要通过cookie来实现了，我们会给每个用户产生的session分配一个唯一的Id，把这个id存放在cookie中，当用户请求服务器的时候会带上sessionId,服务器从cookie中获取sessionId后可以根据Id从缓存中获取到session状态信息。 说到这里，可能有同学会问？为什么我们不能把信息都放到cookie中，这样服务器端都不用存储任何的状态信息，这样对于服务器来说不也是无状态了吗？其实这里面主要涉及安全性以及浏览器的实现问题，因为存储到cookie中的信息是不安全的，黑客可以进行cookie劫持，这样你保存到cookie中的信息就会被非法用户获取了。另外我们知道不同的浏览器对cookie数量以及大小是有限制的，比如IE8限制cookie的大小为4095字节，每个域名cookie的数量为50个，这样以来就可能会遇到cookie丢失的问题。 综上，Session状态的存储，我们需要结合客户端存储和服务器端存储，在客户端存储中，我们借用http cookie来存储sessionId,而session的具体信息我们可以存放到服务器端，而具体实现的过程中，我们可以将起放入分布式缓存服务器中。 Session信息的管理接下来我们再来说说Session信息管理，一些公司可能对这块没有什么重视，session状态的管理完全依赖于开发人员自己，开发人员可以随意将信息写入到cookie或者httpsession中，这样造成的问题就是session状态混乱，最后随着开发人员的离职，新来的人只能通过查看源代码的方式来了解session中都放入了什么信息，到后来可能公司没人知道在cookie或者httpsession中到底存放了哪些信息了？这对与系统的维护以及扩展都是不利的，那么怎么解决这个问题？ 其实这个时候我们就可以通过session信息的统一配置话管理来解决了。具体来说就是Session框架通过一个配置文件对可放入的session信息进行统一的管理，要想往cookie或者服务器session中放入任何信息都要在配置文件中配置，这样才容许写入。这样要知道session中存放了哪些信息只需要查看配置文件即可知道了。 不过采用配置文件管理session信息了以后，可能又会遇到一个问题，配置文件如何管理？这个不同的公司可以有不同的做法，比如配置文件可以存放在数据库中，session框架启动的时候去数据库查询到最新的配置信息，或者也可以将其放入classpath文件中，session框架通过启动的时候去classpath中获取，另外一些公司都有统一的配置管理服务器，这样可以将session配置也纳入到配置管理服务器中，这样就更加规范了。 信息安全性问题上面说了session信息的存储，我们的Session框架要支持两种存储方式，一种是cookie的客户端存储，一种是存储到服务端，当存储到客户端cookie中的，信息容易被非法意图的人窃取，如果什么信息都明文保存在cookie中，那么就存在用户信息泄露的风险。那么此时就需要对放入cookie的信息进行加密处理。关于加密和解密算法本人也没有深入研究过，不过这方面已经有很多人给出了解决方案。我在写Session框架的时候，采用了Blowfish，有兴趣的同学可以去看看。 如何与Servlet Container结合本文的最后，咋们来看看在Java web 开发中，自己开发的Session框架如何与Servlet 容器结合起来。 Servlet规范中有过滤器的概念，过滤器是每个请求过来的时候，可以在请求进入Servlet之前和之后可以做一些通用的事情，那么我们的Session框架可以提供一个SessionFilter纳入到Servlet容器的管理。下面通过一个简单图来形象的描述一下Session框架中主要的角色。 sessionFramework 上图中绿色的部分为Session框架的核心部分，我们下面分别来描述一下。 SessionFilterSessionFilter的主要职责就是对web server生成的HttpServletRequest和HttpServletReponse进行封装，将其封装为CustomHttpServletRequest和CustomHttpServletReponse. SessionFilter的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536/*SessionFilter.java*/@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //对原生的HttpServletRequest和HttpServletReponse进行封装。 CustomSessionServletRequest customRequest = new CustomSessionServletRequest((HttpServletRequest) request); CustomSessionServletResponse customResponse = new CustomSessionServletResponse((HttpServletResponse) response); //对于一些静态资源可以不经过session框架过滤 if (letitgo(request, response, chain, customRequest)) return; //reponseBuffer开关，控制服务器刷新响应流的方式，如果打开的话，会等整个请求处理完成后一次性刷到客户端 if (needResponseBuffered) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"session framework responseBuffered is on\"); &#125; customResponse.setWriterBuffered(true); &#125; CustomSession customSession = createCustomSession(customRequest, customResponse); try &#123; chain.doFilter(customRequest, customResponse); if (null != customSession) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"session framework start to commit session--\" + \"customSession.commit\"); &#125; //将后续业务写入session的信息进行存储，这里就涉及到了将信息写入cookie或者缓存 customSession.commit(); &#125; &#125; catch (Exception ex) &#123; logger.error(\"session framework occur exception\", ex); throw new RuntimeException(ex); &#125; finally &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"session framework start to commit buffer--\" + \"customResponse.commitBuffer\"); &#125; //将响应流刷到客户端 customResponse.commitBuffer(); &#125;&#125; CustomHttpServletRequestCustomHttpServletRequest包转了原生的HttpServletRequest，它最核心的就是要覆盖getSession方法，主要的代码如下： 123456789/*CustomHttpServletRequest.java*/@Overridepublic CustomSession getSession() &#123; return session;&#125;@Overridepublic CustomSession getSession(boolean create) &#123; return getSession();&#125; 这样当应用通过getSession返回的则是经过封装以后的代码。 CustomHttpServletReponseCustomHttpServletReponse封装了原生的HttpServletReponse,此类的实现的时候需要注意在Servlet3.0之前，不支持httponly的cookie，要写入Httponly的cookie需要手动通过addHeader的方法去加入，而Servlet3.0以后，可以直接通过addCookie方法实现，具体的伪代码如下： 1234567public void addCookie(CustomCookie cookie) &#123; if (cookie.isHttpOnly()) &#123; addHeader(SET_COOKIE, buildHttpOnlyCookie(cookie)); &#125; else &#123; super.addCookie(cookie); &#125;&#125; 另外我们知道标准的Servlet 输出流有一个缓存区，当应用向缓存区写入数据的时候，如果缓存区已经满了就会刷流到客户端了，这样的话就有可能造成一种情况：部分流已经刷到客户端了，但是后来服务器处理抛异常了，这样用户可能看到的状态可能和服务器不一致，为了解决这个问题，我们可以重写getOutputStream和getWriter方法，这两个方法在返回一个经过我们包装的输出流，这样Session框架就可以保留应用写入的数据到最后请求处理完了以后再由SessionFilter刷新流到客户端。具体的伪代码可以参考如下： 12345678910111213141516171819202122232425262728293031@Overridepublic ServletOutputStream getOutputStream() throws IOException &#123; if (this.isWriterBuffered) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Created new byte buffer\"); &#125; //这里返回一个ByteArrayOutputStream，方便Session框架控制输出流 ByteArrayOutputStream bytes = new ByteArrayOutputStream(); stream = new BufferedServletOutputStream(bytes); return stream; &#125; else &#123; this.getSession().commit(); return super.getOutputStream(); &#125;&#125;@Overridepublic PrintWriter getWriter() throws IOException &#123; if (this.isWriterBuffered) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"response.getWriter(): Created new character buffer\"); &#125; //这里返回StringWriter 方便Session框架控制输出流 StringWriter chars = new StringWriter(); writer = new BufferedServletWriter(chars); return writer; &#125; else &#123; this.getSession().commit(); return super.getWriter(); &#125;&#125; 另外需要重写的一些方法比如sendError,sendRedirect也需要重写。 CustomHttpSessionCustomHttpSession主要负责管理Session中的状态信息，它是HttpSession的子类，它会根据Session框架的配置，将不同的信息保存到对应的SessionHolder中，对于CustomHttpSession，我们主要需要重写setAttribute和getAttribute方法。它的伪代码如下： 12345678910111213141516171819202122232425@Overridepublic void setAttribute(String name, Object value) &#123; //1. 根据Session框架的配置文件，找到name的属性对应的session配置项 final SessionConfigItem sessionConfigItem = sessionConfig.getSessionConfigItem(name); if (sessionConfigItem == null) &#123; return;//如果配置项为空，说明此name的属性没有经过session框架配置，不能写入 &#125; //2. 根据配置类型获取具体的SessionHolder final SessionHolder sessionHolder = sessionHolders.get(sessionConfigItem.getHolderType()); //2. 找到对应的SessionHolder将其存储 sessionHolder.setAttribute(sessionConfigItem, value);&#125;@Overridepublic Object getAttribute(String name) &#123; final SessionConfigItem sessionConfigItem = sessionConfig.getSessionConfigItem(name); if (sessionConfigItem == null) &#123; return null; &#125; final SessionHolder sessionHolder = sessionHolders.get(sessionConfigItem.getHolderType()); if (sessionHolder == null) &#123; return null; &#125; return sessionHolder.getAttribute(sessionConfigItem);&#125; SessionHolderSessionHolder抽象了Session保存的接口，具体实现可以有好多种，比如你可以选择把session信息保存到cookie中，也可以将其保存到缓存中，甚至你可以将其保存到文件系统中。我自己写的session框架，根据前面的讨论，提供了两种存储方式，CookieHolder和CacheHolder分别对应客户端存储和服务器端缓存存储。在CookieHolder中要涉及到对cookie的解析，保存以及加密等操作，而CacheHolder涉及到从分布式缓存中查询到Session的信息以及同步session信息到缓存等一系列操作，具体代码我就不贴了。","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Session","slug":"Session","permalink":"http://builderqiu.com/tags/Session/"}]},{"title":"Java类加载器","slug":"JavaClassLoaderDetail","date":"2014-08-12T16:00:00.000Z","updated":"2016-12-25T08:22:52.937Z","comments":true,"path":"2014/08/JavaClassLoaderDetail.html","link":"","permalink":"http://builderqiu.com/2014/08/JavaClassLoaderDetail.html","excerpt":"ClassLoader 一、分类：1.BootStrap Class Loader：启动类加载器，负责加载rt.jar文件中所有的Java类，即Java的核心类都是由该ClassLoader加载。在Sun JDK中，这个类加载器是由C++实现的，并且在Java语言中无法获得它的引用。 2.Extension Class Loader：扩展类加载器，负责加载一些扩展功能的jar包。 3.System Class Loader：系统类加载器，负责加载启动参数中指定的Classpath中的jar包及目录，通常我们自己写的Java类也是由该ClassLoader加载。在Sun JDK中，系统类加载器的名字叫AppClassLoader。 4.User Defined Class Loader：用户自定义类加载器，由用户自定义类的加载规则，可以手动控制加载过程中的步骤。","text":"ClassLoader 一、分类：1.BootStrap Class Loader：启动类加载器，负责加载rt.jar文件中所有的Java类，即Java的核心类都是由该ClassLoader加载。在Sun JDK中，这个类加载器是由C++实现的，并且在Java语言中无法获得它的引用。 2.Extension Class Loader：扩展类加载器，负责加载一些扩展功能的jar包。 3.System Class Loader：系统类加载器，负责加载启动参数中指定的Classpath中的jar包及目录，通常我们自己写的Java类也是由该ClassLoader加载。在Sun JDK中，系统类加载器的名字叫AppClassLoader。 4.User Defined Class Loader：用户自定义类加载器，由用户自定义类的加载规则，可以手动控制加载过程中的步骤。 二、工作原理：类加载分为装载、链接、初始化三步。 1.装载通过类的全限定名和ClassLoader加载类，主要是将指定的.class文件加载至JVM。当类被加载以后，在JVM内部就以“类的全限定名+ClassLoader实例ID”来标明类。 在内存中，ClassLoader实例和类的实例都位于堆中，它们的类信息都位于方法区。 装载过程采用了一种被称为“双亲委派模型（Parent Delegation Model）”的方式，当一个ClassLoader要加载类时，它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader，所以称为父ClassLoader可能更容易理解）加载类，而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader，直到启动类加载器。只有其双亲ClassLoader无法加载指定的类时，它才会自己加载类。 双亲委派模型是JVM的第一道安全防线，它保证了类的安全加载，这里同时依赖了类加载器隔离的原理：不同类加载器加载的类之间是无法直接交互的，即使是同一个类，被不同的ClassLoader加载，它们也无法感知到彼此的存在。这样即使有恶意的类冒充自己在核心包（例如java.lang）下，由于它无法被启动类加载器加载，也造成不了危害。 由此也可见，如果用户自定义了类加载器，那就必须自己保障类加载过程中的安全。 2.链接链接的任务是把二进制的类型信息合并到JVM运行时状态中去。 链接分为以下三步： a.验证：校验.class文件的正确性，确保该文件是符合规范定义的，并且适合当前JVM使用。 b.准备：为类分配内存，同时初始化类中的静态变量赋值为默认值。 c.解析（可选）：主要是把类的常量池中的符号引用解析为直接引用，这一步可以在用到相应的引用时再解析。 3.初始化初始化类中的静态变量，并执行类中的static代码、构造函数。 JVM规范严格定义了何时需要对类进行初始化： a、通过new关键字、反射、clone、反序列化机制实例化对象时。 b、调用类的静态方法时。 c、使用类的静态字段或对其赋值时。 d、通过反射调用类的方法时。 e、初始化该类的子类时（初始化子类前其父类必须已经被初始化）。 f、JVM启动时被标记为启动类的类（简单理解为具有main方法的类）。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"http://builderqiu.com/tags/ClassLoader/"}]},{"title":"MySQL之Explain详解","slug":"MySQLExplainDetailFav","date":"2014-07-26T16:00:00.000Z","updated":"2016-12-24T14:31:41.672Z","comments":true,"path":"2014/07/MySQLExplainDetailFav.html","link":"","permalink":"http://builderqiu.com/2014/07/MySQLExplainDetailFav.html","excerpt":"原文 一.语法explain &lt; table_name &gt; 例如: explain select * from t3 where id=3952602;","text":"原文 一.语法explain &lt; table_name &gt; 例如: explain select * from t3 where id=3952602; 二.explain输出解释 id select_type table type possible_keys key key_len ref rows Extra 1.id 我的理解是SQL执行的顺利的标识,SQL从大到小的执行. 例如:mysql&gt; explain select * from (select * from ( select * from t3 where id=3952602) a) b; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY system NULL NULL NULL NULL 1 2 DERIVED system NULL NULL NULL NULL 1 3 DERIVED t3 const PRIMARY,idx_t3_id PRIMARY 4 1 很显然这条SQL是从里向外的执行,就是从id=3 向上执行. 2. select_type就是select类型,可以有以下几种 (1) SIMPLE简单SELECT(不使用UNION或子查询等) 例如:mysql&gt; explain select * from t3 where id=3952602; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 (2). PRIMARY 我的理解是最外层的select.例如: mysql&gt; explain select * from (select * from t3 where id=3952602) a ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY system NULL NULL NULL NULL 1 2 DERIVED t3 const PRIMARY,idx_t3_id PRIMARY 4 1 (3).UNION UNION中的第二个或后面的SELECT语句.例如mysql&gt; explain select * from t3 where id=3952602 union all select * from t3 ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 2 UNION t3 ALL NULL NULL NULL NULL 1000 NULL UNION RESULT ALL NULL NULL NULL NULL NULL (4).DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询 mysql&gt; explain select * from t3 where id in (select id from t3 where id=3952602 union all select id from t3) ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY t3 ALL NULL NULL NULL NULL 1000 Using where 2 DEPENDENT SUBQUERY t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 Using index 3 DEPENDENT UNION t3 eq_ref PRIMARY,idx_t3_id PRIMARY 4 func 1 Using where; Using index NULL UNION RESULT ALL NULL NULL NULL NULL NULL (4).UNION RESULT UNION的结果。 mysql&gt; explain select * from t3 where id=3952602 union all select * from t3 ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 2 UNION t3 ALL NULL NULL NULL NULL 1000 NULL UNION RESULT ALL NULL NULL NULL NULL NULL (5).SUBQUERY 子查询中的第一个SELECT. mysql&gt; explain select * from t3 where id = (select id from t3 where id=3952602 ) ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 2 SUBQUERY t3 const PRIMARY,idx_t3_id PRIMARY 4 1 Using index (6). DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询 mysql&gt; explain select id from t3 where id in (select id from t3 where id=3952602 ) ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY t3 index NULL PRIMARY 4 NULL 1000 Using where; Using index 2 DEPENDENT SUBQUERY t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 Using index (7).DERIVED 派生表的SELECT(FROM子句的子查询) mysql&gt; explain select * from (select * from t3 where id=3952602) a ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY system NULL NULL NULL NULL 1 2 DERIVED t3 const PRIMARY,idx_t3_id PRIMARY 4 1 3.table显示这一行的数据是关于哪张表的.有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果) mysql&gt; explain select * from (select * from ( select * from t3 where id=3952602) a) b; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY system NULL NULL NULL NULL 1 2 DERIVED system NULL NULL NULL NULL 1 3 DERIVED t3 const PRIMARY,idx_t3_id PRIMARY 4 1 4.type这列很重要,显示了连接使用了哪种类别,有无使用索引.从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL (1).system 这是const联接类型的一个特例。表仅有一行满足条件.如下(t3表上的id是 primary key) mysql&gt; explain select * from (select * from t3 where id=3952602) a ; id select_type table type possible_keys key key_len ref rows Extra 1 PRIMARY system NULL NULL NULL NULL 1 2 DERIVED t3 const PRIMARY,idx_t3_id PRIMARY 4 1 (2).const 表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！ const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。在下面的查询中，tbl_name可以用于const表： SELECT * from tbl_name WHERE primary_key=1； SELECT * from tbl_name WHERE primary_key_part1=1和 primary_key_part2=2； 例如: mysql&gt; explain select * from t3 where id=3952602; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE t3 const PRIMARY,idx_t3_id PRIMARY 4 const 1 (3). eq_ref 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。 eq_ref可以用于使用 = 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。 在下面的例子中，MySQL可以使用eq_ref联接来处理ref_tables： SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; 例如: mysql&gt; create unique index idx_t3_id on t3(id) ; mysql&gt; explain select * from t3,t4 where t3.id=t4.accountid; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE t4 ALL NULL NULL NULL NULL 1000 1 SIMPLE t3 eq_ref PRIMARY,idx_t3_id idx_t3_id 4 dbatest.t4.accountid 1 (4).ref 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。 ref可以用于使用=或&lt;=&gt;操作符的带索引的列。 在下面的例子中，MySQL可以使用ref联接来处理ref_tables： SELECT * FROM ref_table WHERE key_column=expr; SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; 例如: mysql&gt; drop index idx_t3_id on t3; mysql&gt; create index idx_t3_id on t3(id) ; mysql&gt; explain select * from t3,t4 where t3.id=t4.accountid; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE t4 ALL NULL NULL NULL NULL 1000 1 SIMPLE t3 ref PRIMARY,idx_t3_id idx_t3_id 4 dbatest.t4.accountid 1 (5). ref_or_null 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。 在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables： SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL; (6). index_merge 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。 例如:mysql&gt; explain select * from t4 where id=3952602 or accountid=31754306 ; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE t4 index_merge idx_t4_id,idx_t4_accountid idx_t4_id,idx_t4_accountid 4,4 NULL 2 Using union(idx_t4_id,idx_t4_accountid); Using where (7). unique_subquery 该类型替换了下面形式的IN子查询的ref： value IN (SELECT primary_key FROM single_table WHERE some_expr)unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。 (8).index_subquery 该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引： value IN (SELECT key_column FROM single_table WHERE some_expr) (9).range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。 当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range mysql&gt; explain select * from t3 where id=3952602 or id=3952603 ; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE t3 range PRIMARY,idx_t3_id idx_t3_id 4 NULL 2 Using where 1 row in set (0.02 sec) (10).index 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。 当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。 (11). ALL 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。 5.possible_keyspossible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询 6. keykey列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。 7.key_lenkey_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好 8. refref列显示使用哪个列或常数与key一起从表中选择行。 9. rowsrows列显示MySQL认为它执行查询时必须检查的行数。 10. Extra该列包含MySQL解决查询的详细信息,下面详细. (1).Distinct一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 (2).Not existsMYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了 (3).Range checked for each Record（index map:#）没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 (4).Using filesort看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 (5).Using index列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 (6).Using temporary看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 (7).Using where使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://builderqiu.com/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"http://builderqiu.com/tags/MySQL/"},{"name":"Explain","slug":"Explain","permalink":"http://builderqiu.com/tags/Explain/"}]},{"title":"Base64编码Java实现","slug":"Base64EncoderDecoderBaseOnJava","date":"2014-07-23T16:00:00.000Z","updated":"2016-12-25T08:22:25.515Z","comments":true,"path":"2014/07/Base64EncoderDecoderBaseOnJava.html","link":"","permalink":"http://builderqiu.com/2014/07/Base64EncoderDecoderBaseOnJava.html","excerpt":"一、什么是Base64编码Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一。Base64 主要不是加密，它主要的用途是把一些二进制数转成普通字符用于网络传输。由于一些二进制字符在传输协议中属于控制字符，不能直接传送需要转换一下。Base64编码就是把二进制字节序列转化为ASCII字符序列。一般增加1/3长度，而且也是不可读的。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。","text":"一、什么是Base64编码Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一。Base64 主要不是加密，它主要的用途是把一些二进制数转成普通字符用于网络传输。由于一些二进制字符在传输协议中属于控制字符，不能直接传送需要转换一下。Base64编码就是把二进制字节序列转化为ASCII字符序列。一般增加1/3长度，而且也是不可读的。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。 二、Base64原理[源数据]——&gt;[获得源数据的二进制流]——&gt;[每3个8位二进制转换为4个6位二进制]——&gt;[每6位二进制转换为十进制]——&gt;[对照表转换为Base64数据] 关键点：3个8位二进制转换4个6位二进制的方法将输入的二进制数据流以每次读取6个bit的方式读取，不足6位的后补0,将每3个8位二进制转换为4个6位二进制，也就是说每3个8位字节将编码为4个6位字节（3×8 → 4×6）；不满4个字节的以“=”填充。其实这4个六位字节仍然是8位，只不过高两位被设置为0。当一个字节只有6位有效时，它的取值空间为0 到 2的6次方减1 即63，也就是说被转换的Base64编码的每一个编码的取值空间为（0-63）。事实上，0-63之间的ASCII码有许多不可见字符，所以应该再做一个映射，映射表（码表）为： 码字 个数 ASCII码 对应的6bit值 0 - 9 10个 48 - 57 52 - 61 A - Z 26个 65 - 90 0 - 25 a - z 26个 96 - 122 26 - 51 + 1个 43 62 / 1个 47 63 三、Base64应用1.mail由于rfc821有以下两条限制： 1)邮件的内容必须全部为7-比特的美国ascii码。 2)每一行的长度不能超过1000的字符当邮件中有其他的非ASCII字符或二进制数据时，就需要做转换。这个就叫做Content-Transfer-Encoding，Base64就是其中的一种方法。在firefox你可以设置自己发送邮件的内容传输编码方式。在收到的邮件里，你可以查看邮件原文，看看原文的编码。 2.URL有些应用需要把二进制数据放到URL里，URL只能是特定的一些ASCII字符。这时候，也需要用到BASE64编码。当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含+/,真正放到URL里面时候，还需要URL-Encoding,变成%XX模式。 3.HTML中内嵌图片就是说这种状况下，图片不是以链接地址的方式嵌到HTML中去的，图片本身已被BASE64成字符串放到HTML页面文本中去了，成为HTML文本的一部分。当HTML页面拉取完成之后，图片数据也就下来了，不再需要再去拉取图片.如下格式： &lt;img src=&#39;data:image/png;base64，base64code&#39;&gt; 这种标签图片的显示需要浏览器的支持，先Base64解码，再去显示不同格式的图片。使用data: URI直接在网页中嵌入，data: URI定义于IETF标准的RFC 2397。data: URI的基本使用格式如下： data:[&lt;MIME-type&gt;][;base64|charset=some_charset],&lt;data&gt; mime-type是嵌入数据的mime类型，比如png图片就是image/png。如果后面跟base64，说明后面的data是采用base64方式进行编码的。获得图片的base64编码，base64编码工具不少，对于前端制作，下面这个本地图片base64编码获取页面是值得推荐的： Encode Data URL By PuterJam 。 4.简单加密迅雷等下载工具，就有他们自己特有的下载链接，如thunder://其实就是把一个HTTP URL资源地址加上了某些东西后再进行BASE64编码，然后加上thunder://头。垃圾讯息传播者用Base64来避过反垃圾邮件工具，因为那些工具通常都不会翻译Base64的讯息。 ###5.百度地图地址转化 百度地图api的地址转化（例如gps坐标-&gt;百度地图坐标）结果，使用了base64加密。 四、Java编码实现/** * * @ClassName: SecurityBase64 * @Description: 用于编码请求参数 * @author BuilderQiu * @date 2013-9-23 上午10:52:1 */ public class SecurityBase64 { //对照表 private static String base64hash = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/&quot;; //&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/&quot;; private SecurityBase64(){} private static class TEMP{ public static final SecurityBase64 instance = new SecurityBase64(); } public static Security getInstance(){ return TEMP.instance; } private void checkSecurity(){ if(&quot;&quot;.equals(base64hash)||base64hash==null||base64hash.length()!=64){ throw new RuntimeException(Security.class+&quot;was initialize failed!&quot;); } } /** * * @Title: encode * @Description: 编码 * @param @param src * @param @return * @return String * @throws */ public String encode(String src){ checkSecurity(); StringBuilder result = new StringBuilder(); byte[] bytes = src.getBytes(); int length = bytes.length; int mod = 0; byte prev = 0; for(int i=0;i&lt;length;i++){ mod = i%3; if(mod==0){ result.append(base64hash.charAt((bytes[i] &gt;&gt; 2) &amp; 0x3F)); }else if(mod==1){ result.append(base64hash.charAt((prev &lt;&lt; 4 | bytes[i] &gt;&gt; 4 &amp;0x0F )&amp; 0x3F)); }else{ result.append(base64hash.charAt((bytes[i] &gt;&gt; 6 &amp; 0x03 | prev &lt;&lt; 2) &amp; 0x3F)); result.append(base64hash.charAt(bytes[i] &amp; 0x3F)); } prev = bytes[i]; } if(mod==0){ result.append(base64hash.charAt(prev &lt;&lt; 4 &amp; 0x3C)); result.append(&quot;==&quot;); }else if(mod==1){ result.append(base64hash.charAt(prev &lt;&lt; 2 &amp; 0x3F)); result.append(&quot;=&quot;); } return result.toString(); } /** * * @Title: decode * @Description: 解码 * @param @param src * @param @return * @return String * @throws */ public String decode(String src){ if(StringUtil.isBlank(src)){ return &quot;&quot;; } checkSecurity(); byte temp = 0; String result = &quot;&quot;; for(int i=0;i&lt;src.length();i++){ temp = (byte) base64hash.indexOf(src.charAt(i)); if(temp==-1){ result+=&quot;000000&quot;; }else{ String t = Integer.toBinaryString(temp); if(t.length()==7){ t = t.substring(1); }else if(t.length()==8){ t = t.substring(2); } while(t.length()&lt;6){ t = &quot;0&quot;+t; } result+=t; } } while(result.endsWith(&quot;00000000&quot;)){ result = result.substring(0,result.length()-8); } byte[] bytes = new byte[result.length()/8]; for(int i=0;i&lt;bytes.length;i++){ bytes[i]= Integer.valueOf(result.substring(i*8,(i+1)*8),2).byteValue(); } return new String(bytes); } public void setBase64hash(String base64hash) { Security.base64hash = base64hash; } /** * * @Title: randomTable * @Description: 生成随机对照表 * @param @return * @return String * @throws */ public static String randomTable(){ String base = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/&quot;; List&lt;Character&gt; list = new ArrayList&lt;Character&gt;(); for(int i=0;i&lt;base.length();i++){ list.add(base.charAt(i)); } Collections.shuffle(list); base = &quot;&quot;; for(Character ch:list){ base += ch; } return base; } } 可用于简单加密，不知道对照表顺序则不能容易的反推出源数据。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"加密解密","slug":"加密解密","permalink":"http://builderqiu.com/tags/加密解密/"},{"name":"Base64","slug":"Base64","permalink":"http://builderqiu.com/tags/Base64/"}]},{"title":"在CentOS中安装jenkins","slug":"JenkinsInstallOnCentOS","date":"2014-07-21T16:00:00.000Z","updated":"2016-12-25T08:23:02.412Z","comments":true,"path":"2014/07/JenkinsInstallOnCentOS.html","link":"","permalink":"http://builderqiu.com/2014/07/JenkinsInstallOnCentOS.html","excerpt":"一、检查java是否安装1234$ java -versionjava version &quot;1.6.0_22&quot;OpenJDK Runtime Environment (IcedTea6 1.10.4) (rhel-1.41.1.10.4.el6-x86_64)OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode) 如果没有安装：yum install java-1.7.0-openjdk* -y","text":"一、检查java是否安装1234$ java -versionjava version &quot;1.6.0_22&quot;OpenJDK Runtime Environment (IcedTea6 1.10.4) (rhel-1.41.1.10.4.el6-x86_64)OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode) 如果没有安装：yum install java-1.7.0-openjdk* -y 二、下载jenkins12345$ mkdir -p jenkins/jenkins_home$ mkdir -p jenkins/jenkins_node$ cd jenkins$ wget http://mirrors.jenkins-ci.org/war/latest/jenkins.war$ tar -zvxf jenkins.war 三、启动jenkins实现启动脚本： 1234567891011$ vim start_jenkins.sh start_jenkins.sh #!/bin/bash JENKINS_ROOT=/home/AAA/jenkins export JENKINS_HOME=$JENKINS_ROOT/jenkins_home java -jar $JENKINS_ROOT/jenkins.war --httpPort=8000$ chmod a+x start_jenkins.sh$ nohup ./start_jenkins.sh &gt; jenkins.log 2&gt;&amp;1 &amp; 四、访问jenkins： 在浏览器中输入http://192.168.0.1:8000 进行Project配置等即可。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://builderqiu.com/tags/CentOS/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://builderqiu.com/tags/Jenkins/"}]},{"title":"Mysql数据备份与恢复命令","slug":"MysqlBackupAndRebackCommand","date":"2014-07-20T16:00:00.000Z","updated":"2016-12-24T14:31:29.085Z","comments":true,"path":"2014/07/MysqlBackupAndRebackCommand.html","link":"","permalink":"http://builderqiu.com/2014/07/MysqlBackupAndRebackCommand.html","excerpt":"原文地址","text":"原文地址 一、备份常用操作基本命令1、备份命令mysqldump格式格式：mysqldump -h主机名 -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql 2、备份MySQL数据库为带删除表的格式备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。 mysqldump --add-drop-table -uusername -ppassword -database databasename &gt; backupfile.sql 3、直接将MySQL数据库压缩备份mysqldump -hhostname -uusername -ppassword -database databasename | gzip &gt; backupfile.sql.gz 4、备份MySQL数据库某个(些)表mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql 5、同时备份多个MySQL数据库mysqldump -hhostname -uusername -ppassword –databases databasename1 databasename2 databasename3 &gt; multibackupfile. 6、仅备份份数据库结构mysqldump –no-data –databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql 7、备份服务器上所有数据库mysqldump –all-databases &gt; allbackupfile.sql 8、还原MySQL数据库的命令mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql 9、还原压缩的MySQL数据库gunzip &lt; backupfile.sql.gz | mysql -uusername -ppassword databasename 10、将数据库转移到新服务器mysqldump -uusername -ppassword databasename | mysql –host=*.*.*.* -C databasename 11、–master-data 和–single-transaction在mysqldump中使用--master-data=2，会记录binlog文件和position的信息。--single-transaction会将隔离级别设置成repeatable-commited 12、导入数据库常用source命令，用use进入到某个数据库，mysql&gt;source d:\\test.sql，后面的参数为脚本文件。 13、查看binlog日志查看binlog日志可用用命令 mysqlbinlog binlog日志名称|more 14、general_logGeneral_log记录数据库的任何操作，查看general_log 的状态和位置可以用命令show variables like &quot;general_log%&quot;,开启general_log可以用命令set global general_log=on 二、增量备份小量的数据库可以每天进行完整备份，因为这也用不了多少时间，但当数据库很大时，就不太可能每天进行一次完整备份了，这时候就可以使用增量备份。增量备份的原理就是使用了mysql的binlog志。 1、首先做一次完整备份： mysqldump -h10.6.208.183 -utest2 -p123 -P3310 --single-transaction --master-data=2 test&gt;test. sql这时候就会得到一个全备文件test.sql 在sql文件中我们会看到：-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;bin-log.000002&#39;, MASTER_LOG_POS=107;是指备份后所有的更改将会保存到bin-log.000002二进制文件中。2、在test库的t_student表中增加两条记录，然后执行flush logs命令。这时将会产生一个新的二进制日志文件bin-log.000003，bin-log.000002则保存了全备过后的所有更改，既增加记录的操作也保存在了bin-log.00002中。 3、再在test库中的a表中增加两条记录，然后误删除t_student表和a表。a中增加记录的操作和删除表a和t_student的操作都记录在bin-log.000003中。 三、恢复1、首先导入全备数据mysql -h10.6.208.183 -utest2 -p123 -P3310 &lt; test.sql，也可以直接在mysql命令行下面用source导入 2、恢复bin-log.000002mysqlbinlog bin-log.000002 |mysql -h10.6.208.183 -utest2 -p123 -P3310 3、恢复部分 bin-log.000003在general_log中找到误删除的时间点，然后更加对应的时间点到bin-log.000003中找到相应的position点，需要恢复到误删除的前面一个position点。 可以用如下参数来控制binlog的区间 --start-position 开始点 --stop-position 结束点 --start-date 开始时间 --stop-date 结束时间 找到恢复点后，既可以开始恢复。 mysqlbinlog mysql-bin.000003 --stop-position=208 |mysql -h10.6.208.183 -utest2 -p123 -P3310","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://builderqiu.com/tags/Mysql/"},{"name":"备份","slug":"备份","permalink":"http://builderqiu.com/tags/备份/"},{"name":"数据库","slug":"数据库","permalink":"http://builderqiu.com/tags/数据库/"}]},{"title":"Nginx配置文件常用部分详解","slug":"NginxConfigDetailInfo","date":"2014-07-18T16:00:00.000Z","updated":"2016-12-24T14:31:24.215Z","comments":true,"path":"2014/07/NginxConfigDetailInfo.html","link":"","permalink":"http://builderqiu.com/2014/07/NginxConfigDetailInfo.html","excerpt":"原文","text":"原文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 65535;&#125;#设定http服务器http&#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 #charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的hash表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #防止网络阻塞 keepalive_timeout 120; #长连接超时时间，单位是秒 #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用 upstream blog.ha97.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.ha97.com ha97.com; index index.html index.htm index.php; root /data/www/ha97; location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;; #定义本虚拟主机的访问日志 access_log /var/log/nginx/ha97access.log access; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125;","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://builderqiu.com/tags/Nginx/"},{"name":"Config","slug":"Config","permalink":"http://builderqiu.com/tags/Config/"}]},{"title":"基于Nginx的Rtmp流媒体服务器环境搭建","slug":"RtmpServerBaseOnNginx","date":"2014-07-10T16:00:00.000Z","updated":"2016-12-25T08:23:27.959Z","comments":true,"path":"2014/07/RtmpServerBaseOnNginx.html","link":"","permalink":"http://builderqiu.com/2014/07/RtmpServerBaseOnNginx.html","excerpt":"一、编译安装wget http://nginx.org/download/nginx-1.4.2.tar.gz wget https://github.com/arut/nginx-rtmp-module/archive/master.zip 安装Nginx需要安装 pcre、openssl库 CentOS：yum install pcre-devel&amp;openssl-devel -y Ubuntu：sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev 1234567tar -zxvf nginx-1.4.2.tar.gzunzip master.zipcd nginx-1.4.2./configure --add-module=../nginx-rtmp-module-master$ make$ make install 默认会安装在：/usr/local/nginx/目录下","text":"一、编译安装wget http://nginx.org/download/nginx-1.4.2.tar.gz wget https://github.com/arut/nginx-rtmp-module/archive/master.zip 安装Nginx需要安装 pcre、openssl库 CentOS：yum install pcre-devel&amp;openssl-devel -y Ubuntu：sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev 1234567tar -zxvf nginx-1.4.2.tar.gzunzip master.zipcd nginx-1.4.2./configure --add-module=../nginx-rtmp-module-master$ make$ make install 默认会安装在：/usr/local/nginx/目录下 二、配置vim /usr/local/nginx/conf/nginx.config 12345678910111213141516171819http &#123; ……&#125;在http节点后面加上rtmp配置：rtmp &#123; server &#123; listen 1935; application live1 &#123; live on; record off; &#125; application vod &#123; play /var/flv;#视频文件存放路径 on_play http://xxxxxx;#播放前调用，返回200则播放继续，3XX则跳转，其他则不播放 ,可以用来做权限校验 &#125; &#125;&#125; 三、播放器配置JwPlayer: 123456789&lt;script type='text/javascript'&gt; jwplayer('xxx').setup(&#123; streamer: 'rtmp://localhost/vod',#RTMP默认1935端口 file: '1.mp4', image: 'view.jpg', width: '100%', aspectratio: '16:9' &#125;);&lt;/script&gt; ckplayer: 123456789&lt;script type='text/javascript'&gt; var flashvars=&#123; f:'rtmp://localhost:1935/vod|1.mp4',//流地址与文件名之间用|分割（需要修改配置文件） c:0, b:0 &#125;; var params=&#123;bgcolor:'#FFF',allowFullScreen:true,allowScriptAccess:'always'&#125;; CKobject.embedSWF('/ckplayer/ckplayer.swf','video_flash','ckplayer_a1','609','366',flashvars,params);&lt;/script&gt; 四、启动Nginx123456$ cd /usr/local/nginx/sbin/$ ./nginx -t #检查配置文件是否OK#如果nginx还没启动$ ./nginx#如果已经启动了$ ./nginx -s reload #重新加载配置文件","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://builderqiu.com/tags/Nginx/"},{"name":"RTMP","slug":"RTMP","permalink":"http://builderqiu.com/tags/RTMP/"}]},{"title":"基于Spring的异步系统实现方案","slug":"AsyncSystemBaseOnSpring","date":"2014-06-23T16:00:00.000Z","updated":"2016-12-25T08:21:58.893Z","comments":true,"path":"2014/06/AsyncSystemBaseOnSpring.html","link":"","permalink":"http://builderqiu.com/2014/06/AsyncSystemBaseOnSpring.html","excerpt":"一般的实现方案 ##发送异步消息所使用的工具类：","text":"一般的实现方案 ##发送异步消息所使用的工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import java.util.Date;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.apache.activemq.command.ActiveMQMapMessage;import org.apache.activemq.command.ActiveMQObjectMessage;import org.apache.shiro.SecurityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.stereotype.Component;@Componentpublic class AsyncUtils &#123; private static Logger log = LoggerFactory.getLogger(AsyncUtils.class); private static JmsTemplate jmsTemplate; private static Destination sendMailDestination; private static Destination LoginLogDestination; private static Destination normalLogDestination; private static Destination pushNotificationDestination; public static void log(String type,String operate)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_NORMAL_LOG))&#123; return; &#125; try&#123; User user = (User) SecurityUtils.getSubject().getSession().getAttribute(\"loginUser\"); if(user==null)&#123; return; &#125; OperateLog log = new OperateLog(user.getId(), user.getName(), operate,type, user.getLastLoginIp()); final ActiveMQObjectMessage message = new ActiveMQObjectMessage(); message.setObject(log); //AsycWorkFactory.sendMessage(message, AsycWork.NORMAL_LOG); jmsTemplate.send(normalLogDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return message; &#125; &#125;); &#125;catch (Exception e) &#123; log.error(\"日志记录出错!\", e); &#125; &#125; public static void sendMail(String address,String title,String content)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_SEND_MAIL))&#123; return; &#125; try&#123; final ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"address\", address); message.setString(\"title\", title); message.setString(\"content\", content); //AsycWorkFactory.sendMessage(message, AsycWork.EMAIL); jmsTemplate.send(sendMailDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return message; &#125; &#125;); &#125;catch (Exception e) &#123; log.error(\"邮件发送出错！\",e); &#125; &#125; public static void loginLog(String uid,String ip,Date date)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_LOG_CLIENTUSER_LOGINLOG))&#123; return; &#125; try&#123; final ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"uid\", uid); message.setString(\"ip\", ip); message.setString(\"date\", DateUtils.formatDateTime(date, \"yyyy-MM-dd HH:mm:ss\")); //AsycWorkFactory.sendMessage(message, AsycWork.LOGIN_LOG); jmsTemplate.send(LoginLogDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return message; &#125; &#125;); &#125;catch (Exception e) &#123; log.error(\"邮件发送出错！\",e); &#125; &#125; public static void pushNotification(String id,String content)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_LOG_CLIENTUSER_LOGINLOG))&#123; return; &#125; try&#123; final ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"id\", id); message.setString(\"content\", content); jmsTemplate.send(normalLogDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return message; &#125; &#125;); &#125;catch (Exception e) &#123; log.error(\"消息推送出错！\",e); &#125; &#125; @Autowired public void setJmsTemplate(JmsTemplate jmsTemplate) &#123; AsyncUtils.jmsTemplate = jmsTemplate; &#125; @Autowired @Qualifier(\"sendMailDestination\") public void setSendMailDestination(Destination sendMailDestination) &#123; AsyncUtils.sendMailDestination = sendMailDestination; &#125; @Autowired @Qualifier(\"LoginLogDestination\") public void setLoginLogDestination(Destination loginLogDestination) &#123; LoginLogDestination = loginLogDestination; &#125; @Autowired @Qualifier(\"normalLogDestination\") public void setNormalLogDestination(Destination normalLogDestination) &#123; AsyncUtils.normalLogDestination = normalLogDestination; &#125; @Autowired @Qualifier(\"pushNotificationDestination\") public void setPushNotificationDestination( Destination pushNotificationDestination) &#123; AsyncUtils.pushNotificationDestination = pushNotificationDestination; &#125;&#125; ##监听异步消息的监听器类（可以给每个类型的消息设定不同的监听器）： 123456789101112131415161718192021@Componentpublic class EmailListener implements MessageListener &#123; private static Logger log = LoggerFactory.getLogger(EmailListener.class); @Override public void onMessage(Message message) &#123; ActiveMQMapMessage msg = (ActiveMQMapMessage) message; try &#123; String address = msg.getString(\"address\"); String title = msg.getString(\"title\"); String content = msg.getString(\"content\"); Constants.sendMail(address, title, content); &#125; catch (Exception e) &#123; log.error(\"异步邮件发送异常\", e); &#125; &#125;&#125; ##使用方式: 123//异步发送邮件AsyncUtils.sendMail(\"邮件地址\",\"主题\",\"内容\");//即可 ##Spring配置文件: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:core=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.9.0.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.1.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-3.1.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\"&gt; &lt;!-- ActiveMQ 异步任务 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 存放异步操作相关需要Spring管理的类的包 --&gt; &lt;context:component-scan base-package=\"com.xxx.core.async\" /&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://192.168.7.21:61616\" /&gt; &lt;/bean&gt; &lt;!-- 带连接池的JMS链接工厂 --&gt; &lt;bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\"&gt; &lt;property name=\"connectionFactory\" ref=\"targetConnectionFactory\" /&gt; &lt;property name=\"maxConnections\" value=\"10\" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"pooledConnectionFactory\" /&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;/bean&gt; &lt;bean id=\"sendMailDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"SendEmail\"/&gt; &lt;/bean&gt; &lt;bean id=\"LoginLogDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"LoginLog\"/&gt; &lt;/bean&gt; &lt;bean id=\"normalLogDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"NormalLog\"/&gt; &lt;/bean&gt; &lt;bean id=\"pushNotificationDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"Notification\"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean id=\"jmsEmailContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"sendMailDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"emailListener\" /&gt; &lt;!-- 设置监听对象 --&gt; &lt;/bean&gt; &lt;bean id=\"jmsLoginLogContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"LoginLogDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"loginLogListener\" /&gt; &lt;!-- 设置监听对象 --&gt; &lt;/bean&gt; &lt;bean id=\"jmsNormalLogContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"normalLogDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"normalLogListener\" /&gt; &lt;!-- 设置监听对象 --&gt; &lt;/bean&gt; &lt;bean id=\"jmsNotificationContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"pushNotificationDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"pushNotificationListener\" /&gt; &lt;!-- 设置监听对象 --&gt; &lt;/bean&gt; &lt;/beans&gt;","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://builderqiu.com/tags/Spring/"},{"name":"Async","slug":"Async","permalink":"http://builderqiu.com/tags/Async/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://builderqiu.com/tags/ActiveMQ/"}]},{"title":"重启Tomcat应用Shell脚本","slug":"RestartTomcatShell","date":"2014-06-23T16:00:00.000Z","updated":"2016-12-25T08:23:25.247Z","comments":true,"path":"2014/06/RestartTomcatShell.html","link":"","permalink":"http://builderqiu.com/2014/06/RestartTomcatShell.html","excerpt":"脚本：杀死并重启tomcat进程 1234567891011121314151617181920212223242526272829303132#!/bin/sh# DEFINE# 获取tomcat进程IDTomcatID=$(ps -ef |grep red5 |grep -w &apos;red5Server&apos;|grep -v &apos;grep&apos;|awk &apos;NR==1 &#123;print $2&#125;&apos;)#NR==1 每次只取一个pid# tomcat启动程序StartTomcat=/opt/red5Server/bin/startup.shTomcatCache=/opt/red5Server/work# 日志输出TomcatMonitorLog=/tmp/TomcatMonitor.logMonitor()&#123; echo &quot;[info]开始监控tomcat...[$(date +&apos;%F %H:%M:%S&apos;)]&quot; while [ $TomcatID ];do echo &quot;[info]当前tomcat进程ID为:$TomcatID,Kill掉...&quot; kill -9 $TomcatID TomcatID=$(ps -ef |grep red5 |grep -w &apos;red5Server&apos;|grep -v &apos;grep&apos;|awk &apos;&#123;print $2&#125;&apos;) done; echo &quot;[info]当前没有tomcat进程&quot; sleep 5 rm -rf $TomcatCache # 清理tomcat缓存 sleep 5 $StartTomcat echo &quot;------------------------------&quot;&#125;Monitor&gt;&gt;$TomcatMonitorLog","text":"脚本：杀死并重启tomcat进程 1234567891011121314151617181920212223242526272829303132#!/bin/sh# DEFINE# 获取tomcat进程IDTomcatID=$(ps -ef |grep red5 |grep -w &apos;red5Server&apos;|grep -v &apos;grep&apos;|awk &apos;NR==1 &#123;print $2&#125;&apos;)#NR==1 每次只取一个pid# tomcat启动程序StartTomcat=/opt/red5Server/bin/startup.shTomcatCache=/opt/red5Server/work# 日志输出TomcatMonitorLog=/tmp/TomcatMonitor.logMonitor()&#123; echo &quot;[info]开始监控tomcat...[$(date +&apos;%F %H:%M:%S&apos;)]&quot; while [ $TomcatID ];do echo &quot;[info]当前tomcat进程ID为:$TomcatID,Kill掉...&quot; kill -9 $TomcatID TomcatID=$(ps -ef |grep red5 |grep -w &apos;red5Server&apos;|grep -v &apos;grep&apos;|awk &apos;&#123;print $2&#125;&apos;) done; echo &quot;[info]当前没有tomcat进程&quot; sleep 5 rm -rf $TomcatCache # 清理tomcat缓存 sleep 5 $StartTomcat echo &quot;------------------------------&quot;&#125;Monitor&gt;&gt;$TomcatMonitorLog 异常：在Linux中执行.sh脚本，异常/bin/sh^M: bad interpreter: No such file or directory。 分析：这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 解决： 1）在windows下转换： 利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。 2）也可在Linux中转换： 首先要确保文件有可执行权限 #sh&gt;chmod a+x filename 然后修改文件格式 #sh&gt;vi filename 利用如下命令查看文件格式 :set ff 或 :set fileformat 可以看到如下信息 fileformat=dos 或 fileformat=unix 利用如下命令修改文件格式 :set ff=unix 或 :set fileformat=unix :wq (存盘退出) 最后再执行文件 #sh&gt;./filename PS:再配合crontab可以完成定时任务调度","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://builderqiu.com/tags/Tomcat/"},{"name":"Shell","slug":"Shell","permalink":"http://builderqiu.com/tags/Shell/"},{"name":"Crontab","slug":"Crontab","permalink":"http://builderqiu.com/tags/Crontab/"}]},{"title":"Mysql用户相关操作","slug":"MysqlUserOperate","date":"2014-06-22T16:00:00.000Z","updated":"2016-12-25T08:24:24.986Z","comments":true,"path":"2014/06/MysqlUserOperate.html","link":"","permalink":"http://builderqiu.com/2014/06/MysqlUserOperate.html","excerpt":"MySQL 默认有个root用户，但是这个用户权限太大，一般只在管理数据库时候才用。如果在项目中要连接 MySQL 数据库，则建议新建一个权限较小的用户来连接。 在 MySQL 命令行模式下输入如下命令可以为 MySQL 创建一个新用户： CREATE USER username IDENTIFIED BY &#39;password&#39;;","text":"MySQL 默认有个root用户，但是这个用户权限太大，一般只在管理数据库时候才用。如果在项目中要连接 MySQL 数据库，则建议新建一个权限较小的用户来连接。 在 MySQL 命令行模式下输入如下命令可以为 MySQL 创建一个新用户： CREATE USER username IDENTIFIED BY &#39;password&#39;; 新用户创建完成，但是此刻如果以此用户登陆的话，会报错，因为我们还没有为这个用户分配相应权限，分配权限的命令如下： GRANT ALL PRIVILEGES ON *.* TO &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;; 授予username用户在所有数据库上的所有权限。 GRANT REPLICATION SLAVE ON *.* TO &#39;backup&#39;@&#39;address&#39; IDENTIFIED BY &#39;backup_xxx&#39;;创建主从同步数据的账号 如果此时发现刚刚给的权限太大了，如果我们只是想授予它在某个数据库上的权限，那么需要切换到root 用户撤销刚才的权限，重新授权： REVOKE ALL PRIVILEGES ON *.* FROM &#39;username&#39;@&#39;localhost&#39;; GRANT ALL PRIVILEGES ON dbnames.* TO &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;; 甚至还可以指定该用户只能执行 select 和 update 命令： GRANT SELECT, UPDATE ON dbnames.* TO &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;; 这样一来，再次以username登陆 MySQL，只有dbnames数据库是对其可见的，并且如果你只授权它select权限，那么它就不能执行除select之外的语句。 另外每当调整权限后，通常需要执行以下语句刷新权限： FLUSH PRIVILEGES; 删除刚才创建的用户： DROP USER username@localhost; 仔细上面几个命令，可以发现不管是授权，还是撤销授权，都要指定响应的host（即 @ 符号后面的内容），因为以上及格命令实际上都是在操作mysql数据库中的user表，可以用如下命令查看相应用户及对应的host: SELECT User, Host FROM user; 当然，这个表中还包含很多其它例如用户密码、权限设置等很多内容，操作时候尤其需要小心。 忘记Root密码：开启防火墙，确保在其他人不会连接到数据库的时候： 关闭Mysql，并修改配置文件(my.cnf)：在[mysqld]下面添加：skip-grant-tables。 重启mysql，连接之后即可修改root密码","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://builderqiu.com/tags/Mysql/"}]},{"title":"Groovy基础语法","slug":"GroovyBase","date":"2014-06-03T16:00:00.000Z","updated":"2016-12-25T08:22:41.464Z","comments":true,"path":"2014/06/GroovyBase.html","link":"","permalink":"http://builderqiu.com/2014/06/GroovyBase.html","excerpt":"1.Groovy 是没有类型的Java，所以定义变量的时候可以不指定类型,Groovy会根据对象的值来判断其类型12def str = \"Hello world\" println str.class","text":"1.Groovy 是没有类型的Java，所以定义变量的时候可以不指定类型,Groovy会根据对象的值来判断其类型12def str = \"Hello world\" println str.class 2.通过Groovy进行循环在Groovy中，for循环变得更简洁，更易阅读。首先，范围的定义方式更加简洁：0..4表明包含整数0,1,2,3,4; 0..&lt;4 表示0,1,2,3; a..e 表示 a,b,c,d,e 123for(i in 1..5)&#123; println i &#125; Groovy也支持默认参数值 12345678def repeat(val, repeat=5)&#123; for(i in 0..&lt;repeat)&#123; println val &#125; &#125;repeat(\"Hello world\",2) repeat(\"foo\",4) 3. 操作集合在Groovy中，我们可以用范围来定义集合或者数组。如： 1234def range = 0..4 println range.class def coll = [\"Groovy\",\"Java\",\"Ruby\"] println coll.class 为某个集合添加元素时，我们可以使用以下几种方法 123coll.add(\"Python\") coll &lt;&lt; \"Smalltalk\" coll[5] = \"Perl\" 检索方式也更加灵活 1println coll[1] Groovy还允许在集合中增加或去掉集合 12345def numbers = [1,2,3,4] def numbers2 = numbers +5 //=[1,2,3,4,5] println numbers2 def numbers3 = numbers - [2,3]//=[1,4] println numbers3 一些特殊调用 1234def numbers = [1,2,3,4] println numbers.join(\";\") //= 1;2;3;4 ,将集合的元素拼接成了字符串 println [1,2,3,4,3].count(3) //=2 统计元素出现的次数 [\"Java\",\"Groovy\"]*.toUpperCase() // 全部转换成大写 请注意 *. 标记。对于以上列表中的每个值，都会调用 toUpperCase()，生成的集合中每个 String 实例都是大写的. 4.映射定义Map 12def hash = [name:\"Andy\", \"VPN-#\":45] println hash.getClass() //=java.util.LinkedHashMap name 看起来像一个变量，但是在幕后，Groovy 会将它变成 String。操作键值对 1234hash.put(\"id\",23) hash.get(\"name\") hash.dob = \"01/29/76\" println hash[\"name\"] //=\"Andy\" 请注意，在使用 [] 语法从映射获取项时，必须将项作为 String 引用。 5.闭包使用闭包对集合进行迭代 12345def acoll = [\"Groovy\", \"Java\", \"Ruby\"] acoll.each&#123; println it &#125; 请注意，each 直接在 acoll 实例内调用，而 acoll 实例的类型是 ArrayList。在 each 调用之后，引入了一种新的语法 — {，然后是一些代码，然后是 }。由 {} 包围起来的代码块就是闭包。 闭包中的 it 变量是一个关键字，指向被调用的外部集合的每个值 — 它是默认值，可以用传递给闭包的参数覆盖它。下面的代码执行同样的操作，但使用自己的项变量： 12345def acoll = [\"Groovy\", \"Java\", \"Ruby\"] acoll.each&#123; value -&gt; println value &#125; 使用闭包迭代Map 1234def hash = [name:\"Andy\", \"VPN-#\":45] hash.each&#123; key, value -&gt; println \"$&#123;key&#125; : $&#123;value&#125;\" &#125; 闭包的其他用途：因为闭包是一个代码块，所以能够作为参数进行传递（Groovy 中的函数或方法不能这样做）。闭包在调用的时候才会执行这一事实（不是在定义的时候）使得它们在某些场合上特别有用。 123def excite = &#123; word -&gt; return \"$&#123;word&#125;!!\" &#125; 可以通过两种方法调用闭包：直接调用或者通过 call() 方法调用 12assert \"Groovy!!\" == excite(\"Groovy\") assert \"Java!!\" == excite.call(\"Java\") 6.Groovy 中的类Groovy类就是Java类，我们先定义一个bean. 123456789class Song &#123; def name def artist def genre static void main(args) &#123; def sng = new Song(name:\"Le Freak\", artist:\"Chic\", genre:\"Disco\") &#125; &#125; Groovy 自动提供一个构造函数，构造函数接受一个名称-值对的映射，这些名称-值对与类的属性相对应。这是 Groovy 的一项开箱即用的功能,除此之外，Groovy还生成了标准的 setter 和 getter 方法,所以可以像下面这样直接操纵类的属性，这些操作实际上都是通过setter,getter方法进行的，默认情况下，类的属性是私有的： 123456def sng3 = new Song() sng3.name = \"Funkytown\" sng3.artist = \"Lipps Inc.\" sng3.setGenre(\"Disco\") assert sng3.getArtist() == \"Lipps Inc.\" 方法覆盖： 123String toString()&#123; \"$&#123;name&#125;, $&#123;artist&#125;, $&#123;genre&#125;\" &#125; 在 Groovy 中可以省略 return 语句。Groovy 默认返回方法的最后一行。所以在这个示例中，返回包含类属性的 String。 空指针安全性Groovy 通过 ? 操作符提供了一个安全网 — 在方法调用前面添加一个 ? 就相当于在调用前面放了一个条件，可以防止在 null 对象上调用方法。 1234def d=null println d?.toUpperCase() d=\"Hello world\" println d?.toUpperCase()","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://builderqiu.com/tags/Java/"},{"name":"Groovy","slug":"Groovy","permalink":"http://builderqiu.com/tags/Groovy/"}]},{"title":"获取泛型类型工具类","slug":"JavaGenricUtils","date":"2014-06-02T16:00:00.000Z","updated":"2016-12-25T08:22:57.209Z","comments":true,"path":"2014/06/JavaGenricUtils.html","link":"","permalink":"http://builderqiu.com/2014/06/JavaGenricUtils.html","excerpt":"Java泛型在编译阶段会进行泛型擦除，所以能够在运行期获得的泛型是在编译阶段已经确定(继承的泛型类)了的。","text":"Java泛型在编译阶段会进行泛型擦除，所以能够在运行期获得的泛型是在编译阶段已经确定(继承的泛型类)了的。 123456789101112131415161718192021222324public class GenricUtils &#123; /** * 获得泛型类型 * @param clz * @return */ public static &lt;T&gt; Class&lt;T&gt; getGenricClassType(Class clz)&#123; Type type = clz.getGenericSuperclass(); if(type instanceof ParameterizedType)&#123; ParameterizedType pt = (ParameterizedType) type; Type[] types = pt.getActualTypeArguments(); if(types.length &gt; 0 &amp;&amp; types[0] instanceof Class)&#123; return (Class) types[0]; &#125; &#125; return (Class) Object.class; &#125;&#125; 比如: 12345678910111213class TestA&lt;T&gt;&#123; private Class&lt;T&gt; clz = GenricUtils.getGenricClassType(TestA.class); public void get(String id)&#123; session.get(clz,id); &#125;&#125;class TestB extends TestA&lt;String&gt;&#123;&#125; 在执行: 12System.out.println(getGenricClassType(TestA.class));System.out.println(getGenricClassType(TestB.class)); 输出的结果分别为： 12class java.lang.Objectclass java.lang.String","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://builderqiu.com/tags/泛型/"}]},{"title":"Linux服务器软件安装备忘","slug":"LinuxSoftwareInstallBackup","date":"2014-05-28T16:00:00.000Z","updated":"2016-12-25T08:23:08.720Z","comments":true,"path":"2014/05/LinuxSoftwareInstallBackup.html","link":"","permalink":"http://builderqiu.com/2014/05/LinuxSoftwareInstallBackup.html","excerpt":"","text":"1.Centos安装Mysql123456789101112131415161718192021222324252627282930--安装yum install mysql-server 卸载 yum -e mysql-server--设置为开机启动chkconfig mysqld on--启动mysqlservice mysqld start--设置root密码mysqladmin -u root password &apos;xxx&apos;&lt;!-- more --&gt;#双机热备GRANT REPLICATION SLAVE ON *.* TO &apos;backup&apos;@&apos;192.168.1.33&apos; IDENTIFIED BY &apos;backup_xxx&apos;;#一般账号--GRANT ALL PRIVILEGES ON *.* TO &apos;username&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;;flush privileges;乱码：[mysqld]#adddefault-character-set = utf8character-set-server = utf8collation-server = utf8_general_ciinit_connect = &apos;SET collation_connection = utf_general_ci&apos;init_connect = &apos;SET NAMES utf8&apos;[mysqld_safe] 2.安装Redis1234wget http://download.redis.io/releases/redis-2.8.7.tar.gz or http://download.redis.io/releases/redis-2.6.17.tar.gztar -zvxf xxxconfiguremake &amp;&amp; make install 3.启动memcached1memcached -d -m 100 -u root -p 11211 -P /tmp/memcached.pid 4.防火墙：12345678910111213141516171819202122232425262728Iptables:启动iptablesservice iptables startiptables --list //*查看iptables规则集*//下面是没有定义规划时iptables的样子:Chain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy ACCEPT)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destination如何开启/关闭指定端口例如:开启81端口：iptables -I INPUT -i eth0 -p tcp --dport 81 -j ACCEPTiptables -I OUTPUT -o eth0 -p tcp --sport 81 -j ACCEPT关闭81端口：iptables -I INPUT -i eth0 -p tcp --dport 81 -j DROPiptables -I OUTPUT -o eth0 -p tcp --sport 81 -j DROP然后保存/etc/rc.d/init.d/iptables save你可以使用lsof命令来查看某一端口是否开放.查看端口可以这样来使用.我就以81端口为例：lsof -i:81如果有显示说明已经开放了.如果没有显示说明没有开放 5.环境变量12345Tomcat JVM配置--catalina.bat/catalina.shwindowsset JAVA_OPTS = -Xmx512m -Xms512m -XX:MaxPermSize=256mlinuxJAVA_OPTS =&quot;-server -Xmx400m -Xms400m -Xmn128m -XX:MaxPermSize=128m -XX:PermSize=128m&quot; 6.项目直接访问123456【Tomcat直接访问项目--去掉访问路径上的项目名称】修改Tomcat_Home/conf/server.xml&lt;Host&gt; 下添加 &lt;Context path=&quot;&quot; docBase=&quot;项目路径&quot; reloadable=&quot;true&quot; /&gt;path为访问路径，与request.getContextPath()返回值一样。 7.Nginx配置：安装 pcre-devel openssl-devel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657http&#123; #... gzip on; gzip_min_length 1k; gzip_buffers 16 64k; gzip_http_version 1.1; gzip_comp_level 4; gzip_types text/plain text/css application/xml image/png; #... gzip_vary on; sendfile on; client_max_body_size 1024m;#附件上传 upstream e_learning&#123; server 192.168.1.30:8080; server 192.168.1.31:8080; ip_hash; &#125; server&#123; listen 80; server_name 192.168.1.34; index index.jsp; location / &#123; index index.jsp; proxy_pass http://e_learning; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ^~ /upload/ &#123; expires 10d; root /var/e_learning; &#125; location ^~ /vod &#123; proxy_pass http://192.168.1.36:1935/vod/; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~*\\.(gif|jpg|png|js|css)$ &#123; expires 10d; proxy_pass http://e_learning; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125;&#125;","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[]},{"title":"Git常用命令","slug":"GitComand","date":"2014-05-25T16:00:00.000Z","updated":"2016-12-25T08:22:39.135Z","comments":true,"path":"2014/05/GitComand.html","link":"","permalink":"http://builderqiu.com/2014/05/GitComand.html","excerpt":"创建版本库12$ git clone &lt;url&gt; #克隆远程版本库$ git init #初始化本地版本库","text":"创建版本库12$ git clone &lt;url&gt; #克隆远程版本库$ git init #初始化本地版本库 修改和提交123456789$ git status #查看状态$ git diff #查看变更内容$ git add . #跟踪所有改动过的文件$ git add &lt;file&gt; #跟踪指定的文件$ git mv &lt;old&gt; &lt;new&gt; #文件改名$ git rm &lt;file&gt; #删除文件$ git rm --cached &lt;file&gt; #停止跟踪文件但不删除$ git commit -m “commit message” #提交所有更新过的文件$ git commit --amend #修改最后一次提交 查看提交历史123$ git log #查看提交历史$ git log -p &lt;file&gt; #查看指定文件的提交历史$ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史 撤消1234$ git reset --hard HEAD #撤消工作目录中所有未提交文件的修改内容$ git checkout HEAD &lt;file&gt; #撤消指定的未提交文件的修改内容$ git checkout --&lt;File&gt; #让这个文件回到最近一次commit或add时的状态$ git revert &lt;commit&gt; #撤消指定的提交 分支与标签1234567891011121314$ git branch #显示所有本地分支$ git checkout &lt;branch/tag&gt; #切换到指定分支或标签$ git checkout -c &lt;branch/tag&gt; #创建并切换到指定分支或标签$ git branch &lt;new-branch&gt; #创建新分支$ git branch -d &lt;branch&gt; #删除本地分支$ git tag #列出所有本地标签$ git tag -a tagname -m &quot; &quot; #可以指定标签信息# git show #可以查看标签详细信息$ git tag &lt;tagname&gt; #基于最新提交创建标签$ git tag -d &lt;tagname&gt; #删除标签$ git push origin tagname #可以推送一个本地标签$ git push origin --tags #可以推送全部未推送过的本地标签$ git tag -d tagname #可以删除一个本地标签$ git push origin :refs/tags/tagname #可以删除一个远程标签 合并与衍合12$ git merge &lt;branch&gt; #合并指定分支到当前分支$ git rebase &lt;branch&gt; #衍合指定分支到当前分支 远程操作12345678$ git remote -v #查看远程版本库信息$ git remote show &lt;remote&gt; #查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库$ git fetch &lt;remote&gt; #从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; #删除远程分支或标签$ git push --tags #上传所有标签 图片Git常用命令","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"git","slug":"git","permalink":"http://builderqiu.com/tags/git/"}]},{"title":"基于Redis的在线用户列表解决方案","slug":"OnlineListByRedis","date":"2014-05-25T16:00:00.000Z","updated":"2016-12-25T08:23:20.876Z","comments":true,"path":"2014/05/OnlineListByRedis.html","link":"","permalink":"http://builderqiu.com/2014/05/OnlineListByRedis.html","excerpt":"前言：由于项目需求，需要在集群环境下实现在线用户列表的功能，并依靠在线列表实现用户单一登陆（同一账户只能一处登陆）功能： 在单机环境下，在线列表的实现方案可以采用SessionListener来完成，当有Session创建和销毁的时候做相应的操作即可完成功能及将相应的Session的引用存放于内存中，由于持有了所有的Session的引用，故可以方便的实现用户单一登陆的功能（比如在第二次登陆的时候使之前登陆的账户所在的Session失效）。 而在集群环境下，由于用户的请求可能分布在不同的Web服务器上，继续将在线用户列表储存在单机内存中已经不能满足需要，不同的Web服务器将会产生不同的在线列表，并且不能有效的实现单一用户登陆的功能，因为某一用户可能并不在接受到退出请求的Web服务器的在线用户列表中（在集群中的某台服务器上完成的登陆操作，而在其他服务器上完成退出操作）。","text":"前言：由于项目需求，需要在集群环境下实现在线用户列表的功能，并依靠在线列表实现用户单一登陆（同一账户只能一处登陆）功能： 在单机环境下，在线列表的实现方案可以采用SessionListener来完成，当有Session创建和销毁的时候做相应的操作即可完成功能及将相应的Session的引用存放于内存中，由于持有了所有的Session的引用，故可以方便的实现用户单一登陆的功能（比如在第二次登陆的时候使之前登陆的账户所在的Session失效）。 而在集群环境下，由于用户的请求可能分布在不同的Web服务器上，继续将在线用户列表储存在单机内存中已经不能满足需要，不同的Web服务器将会产生不同的在线列表，并且不能有效的实现单一用户登陆的功能，因为某一用户可能并不在接受到退出请求的Web服务器的在线用户列表中（在集群中的某台服务器上完成的登陆操作，而在其他服务器上完成退出操作）。 现有解决方案：1.将用户的在线情况记录进入数据库中，依靠数据库完成对登陆状况的检测 2.将在线列表放在一个公共的缓存服务器上 由于缓存服务器可以为缓存内容设置指定有效期，可以方便实现Session过期的效果，以及避免让数据库的读写性能成为系统瓶颈等原因，我们采用了Redis来作为缓存服务器用于实现该功能。 单机环境下的解决方案：基于HttpSessionListener：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Date;import java.util.Hashtable;import java.util.Iterator;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import com.xxx.common.util.StringUtil;/** * * @ClassName: SessionListener * @Description: 记录所有登陆的Session信息，为在线列表做基础 * @author BuilderQiu * @date 2013-9-18 09:35:13 * */public class SessionListener implements HttpSessionListener &#123; //在线列表&lt;uid,session&gt; private static Hashtable&lt;String,HttpSession&gt; sessionList = new Hashtable&lt;String, HttpSession&gt;(); public void sessionCreated(HttpSessionEvent event) &#123; //不做处理，只处理登陆用户的列表 &#125; public void sessionDestroyed(HttpSessionEvent event) &#123; removeSession(event.getSession()); &#125; public static void removeSession(HttpSession session)&#123; if(session == null)&#123; return ; &#125; String uid=(String)session.getAttribute(\"clientUserId\");//已登陆状态会将用户的UserId保存在session中 if(!StringUtil.isBlank(uid))&#123;//判断是否登陆状态 removeSession(uid); &#125; &#125; public static void removeSession(String uid)&#123; HttpSession session = sessionList.get(uid); try&#123; sessionList.remove(uid);//先执行，防止session.invalidate()报错而不执行 if(session != null)&#123; session.invalidate(); &#125; &#125;catch (Exception e) &#123; System.out.println(\"Session invalidate error!\"); &#125; &#125; public static void addSession(String uid,HttpSession session)&#123; sessionList.put(uid, session); &#125; public static int getSessionCount()&#123; return sessionList.size(); &#125; public static Iterator&lt;HttpSession&gt; getSessionSet()&#123; return sessionList.values().iterator(); &#125; public static HttpSession getSession(String id)&#123; return sessionList.get(id); &#125; public static boolean contains(String uid)&#123; return sessionList.containsKey(uid); &#125; /** * * @Title: isLoginOnThisSession * @Description: 检测是否已经登陆 * @param @param uid 用户UserId * @param @param sid 发起请求的用户的SessionId * @return boolean true 校验通过 */ public static boolean isLoginOnThisSession(String uid,String sid)&#123; if(uid==null||sid==null)&#123; return false; &#125; if(contains(uid))&#123; HttpSession session = sessionList.get(uid); if(session!=null&amp;&amp;session.getId().equals(sid))&#123; return true; &#125; &#125; return false; &#125;&#125; 用户的在线状态全部维护记录在sessionList中，并且可以通过sessionList获取到任意用户的session对象，可以用来完成使指定用户离线的功能(调用该用户的session.invalidate()方法)。 用户登录的时候调用addSession(uid,session)方法将用户与其登录的Session信息记录至sessionList中，再退出的时候调用removeSession(session) or removeSession(uid)方法，在强制下线的时候调用removeSession(uid)方法，以及一些其他的操作即可实现相应的功能。 基于Redis的解决方案：该解决方案的实质是将在线列表的所在的内存共享出来，让集群环境下所有的服务器都能够访问到这部分数据，并且将用户的在线状态在这块内存中进行维护。 Redis连接池工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341import java.util.ResourceBundle;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class RedisPoolUtils &#123; private static final JedisPool pool; static&#123; ResourceBundle bundle = ResourceBundle.getBundle(\"redis\"); JedisPoolConfig config = new JedisPoolConfig(); if (bundle == null) &#123; throw new IllegalArgumentException(\"[redis.properties] is not found!\"); &#125; //设置池配置项值 config.setMaxActive(Integer.valueOf(bundle.getString(\"jedis.pool.maxActive\"))); config.setMaxIdle(Integer.valueOf(bundle.getString(\"jedis.pool.maxIdle\"))); config.setMaxWait(Long.valueOf(bundle.getString(\"jedis.pool.maxWait\"))); config.setTestOnBorrow(Boolean.valueOf(bundle.getString(\"jedis.pool.testOnBorrow\"))); config.setTestOnReturn(Boolean.valueOf(bundle.getString(\"jedis.pool.testOnReturn\"))); pool = new JedisPool(config, bundle.getString(\"redis.ip\"),Integer.valueOf(bundle.getString(\"redis.port\")) ); &#125; /** * * @Title: release * @Description: 释放连接 * @param @param jedis * @return void * @throws */ public static void release(Jedis jedis)&#123; pool.returnResource(jedis); &#125; public static Jedis getJedis()&#123; return pool.getResource(); &#125;&#125;Redis在线列表工具类：import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.List;import java.util.Set;import net.sf.json.JSONObject;import net.sf.json.JsonConfig;import net.sf.json.processors.JsonValueProcessor;import cn.sccl.common.util.StringUtil;import com.xxx.common.util.JsonDateValueProcessor;import com.xxx.user.model.ClientUser;import redis.clients.jedis.Jedis;import redis.clients.jedis.Pipeline;import tools.Constants;/** * * Redis缓存中存放两组key： * 1.SID_PREFIX开头，存放登陆用户的SessionId与ClientUser的Json数据 * 2.UID_PREFIX开头，存放登录用户的UID与SessionId对于的数据 * * 3.VID_PREFIX开头，存放位于指定页面用户的数据（与Ajax一起使用，用于实现指定页面同时浏览人数的限制功能） * * @ClassName: OnlineUtils * @Description: 在线列表操作工具类 * @author BuilderQiu * @date 2014-1-9 上午09:25:43 * */public class OnlineUtils &#123; //KEY值根据SessionID生成 private static final String SID_PREFIX = \"online:sid:\"; private static final String UID_PREFIX = \"online:uid:\"; private static final String VID_PREFIX = \"online:vid:\"; private static final int OVERDATETIME = 30 * 60; private static final int BROADCAST_OVERDATETIME = 70;//ax每60秒发起一次，超过BROADCAST_OVERDATETIME时间长度未发起表示已经离开该页面 public static void login(String sid,ClientUser user)&#123; Jedis jedis = RedisPoolUtils.getJedis(); jedis.setex(SID_PREFIX+sid, OVERDATETIME, userToString(user)); jedis.setex(UID_PREFIX+user.getId(), OVERDATETIME, sid); RedisPoolUtils.release(jedis); &#125; public static void broadcast(String uid,String identify)&#123; if(uid==null||\"\".equals(uid)) //异常数据，正常情况下登陆用户才会发起该请求 return ; Jedis jedis = RedisPoolUtils.getJedis(); jedis.setex(VID_PREFIX+identify+\":\"+uid, BROADCAST_OVERDATETIME, uid); RedisPoolUtils.release(jedis); &#125; private static String userToString(ClientUser user)&#123; JsonConfig config = new JsonConfig(); JsonValueProcessor processor = new JsonDateValueProcessor(\"yyyy-MM-dd HH:mm:ss\"); config.registerJsonValueProcessor(Date.class, processor); JSONObject obj = JSONObject.fromObject(user, config); return obj.toString(); &#125; /** * * @Title: logout * @Description: 退出 * @param @param sessionId * @return void * @throws */ public static void logout(String sid,String uid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); jedis.del(SID_PREFIX+sid); jedis.del(UID_PREFIX+uid); RedisPoolUtils.release(jedis); &#125; /** * * @Title: logout * @Description: 退出 * @param @param UserId 使指定用户下线 * @return void * @throws */ public static void logout(String uid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); //删除sid jedis.del(SID_PREFIX+jedis.get(UID_PREFIX+uid)); //删除uid jedis.del(UID_PREFIX+uid); RedisPoolUtils.release(jedis); &#125; public static String getClientUserBySessionId(String sid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); String user = jedis.get(SID_PREFIX+sid); RedisPoolUtils.release(jedis); return user; &#125; public static String getClientUserByUid(String uid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); String user = jedis.get(SID_PREFIX+jedis.get(UID_PREFIX+uid)); RedisPoolUtils.release(jedis); return user; &#125; /** * * @Title: online * @Description: 所有的key * @return List * @throws */ public static List online()&#123; Jedis jedis = RedisPoolUtils.getJedis(); Set online = jedis.keys(SID_PREFIX+\"*\"); RedisPoolUtils.release(jedis); return new ArrayList(online); &#125; /** * * @Title: online * @Description: 分页显示在线列表 * @return List * @throws */ public static List onlineByPage(int page,int pageSize) throws Exception&#123; Jedis jedis = RedisPoolUtils.getJedis(); Set onlineSet = jedis.keys(SID_PREFIX+\"*\"); List onlines =new ArrayList(onlineSet); if(onlines.size() == 0)&#123; return null; &#125; Pipeline pip = jedis.pipelined(); for(Object key:onlines)&#123; pip.get(getKey(key)); &#125; List result = pip.syncAndReturnAll(); RedisPoolUtils.release(jedis); List&lt;ClientUser&gt; listUser=new ArrayList&lt;ClientUser&gt;(); for(int i=0;i&lt;result.size();i++)&#123; listUser.add(Constants.json2ClientUser((String)result.get(i))); &#125; Collections.sort(listUser,new Comparator&lt;ClientUser&gt;()&#123; public int compare(ClientUser o1, ClientUser o2) &#123; return o2.getLastLoginTime().compareTo(o1.getLastLoginTime()); &#125; &#125;); onlines=listUser; int start = (page - 1) * pageSize; int toIndex=(start+pageSize)&gt;onlines.size()?onlines.size():start+pageSize; List list = onlines.subList(start, toIndex); return list; &#125; private static String getKey(Object obj)&#123; String temp = String.valueOf(obj); String key[] = temp.split(\":\"); return SID_PREFIX+key[key.length-1]; &#125; /** * * @Title: onlineCount * @Description: 总在线人数 * @param @return * @return int * @throws */ public static int onlineCount()&#123; Jedis jedis = RedisPoolUtils.getJedis(); Set online = jedis.keys(SID_PREFIX+\"*\"); RedisPoolUtils.release(jedis); return online.size(); &#125; /** * 获取指定页面在线人数总数 */ public static int broadcastCount(String identify) &#123; Jedis jedis = RedisPoolUtils.getJedis(); Set online = jedis.keys(VID_PREFIX+identify+\":*\"); RedisPoolUtils.release(jedis); return online.size(); &#125; /** * 自己是否在线 */ public static boolean broadcastIsOnline(String identify,String uid) &#123; Jedis jedis = RedisPoolUtils.getJedis(); String online = jedis.get(VID_PREFIX+identify+\":\"+uid); RedisPoolUtils.release(jedis); return !StringUtil.isBlank(online);//不为空就代表已经找到数据了，也就是上线了 &#125; /** * 获取指定页面在线人数总数 */ public static int broadcastCount() &#123; Jedis jedis = RedisPoolUtils.getJedis(); Set online = jedis.keys(VID_PREFIX+\"*\"); RedisPoolUtils.release(jedis); return online.size(); &#125; /** * * @Title: isOnline * @Description: 指定账号是否登陆 * @param @param sessionId * @param @return * @return boolean * @throws */ public static boolean isOnline(String uid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); boolean isLogin = jedis.exists(UID_PREFIX+uid); RedisPoolUtils.release(jedis); return isLogin; &#125; public static boolean isOnline(String uid,String sid)&#123; Jedis jedis = RedisPoolUtils.getJedis(); String loginSid = jedis.get(UID_PREFIX+uid); RedisPoolUtils.release(jedis); return sid.equals(loginSid); &#125;&#125; 由于在线状态是记录在Redis中的，并不单纯依靠Session的过期机制来实现，所以需要通过拦截器在每次发送请求的时候去更新Redis中相应的缓存过期时间来更新用户的在线状态。 登陆、退出操作与单机版相似，强制下线需要配合拦截器实现，当用户下次访问的时候，自己来校验自己的状态是否为已经下线，不再由服务器控制。 配合拦截器实现在线状态维持与强制登陆(使其他地方登陆了该账户的用户下线)功能： 123456789101112...if(uid != null)&#123;//已登录 if(!OnlineUtils.isOnline(uid, session.getId()))&#123; session.invalidate(); return ai.invoke(); &#125;else&#123; OnlineUtils.login(session.getId(), (ClientUser)session.getAttribute(\"clientUser\")); //刷新缓存 &#125;&#125;... 注：Redis在线列表工具类中的部分代码是后来需要实现限制同时访问指定页面浏览人数功能而添加的，同样基于Redis实现，前端由Ajax轮询来更新用户停留页面的状态。 附录：Redis连接池配置文件：1234567891011121314151617###redis##config#########redis服务器ip ##redis.ip=localhost#redis服务器端口号#redis.port=6379###jedis##pool##config####jedis的最大分配对象#jedis.pool.maxActive=1024#jedis最大保存idel状态对象数 #jedis.pool.maxIdle=200#jedis池没有对象返回时，最大等待时间 #jedis.pool.maxWait=1000#jedis调用borrowObject方法时，是否进行有效检查#jedis.pool.testOnBorrow=true#jedis调用returnObject方法时，是否进行有效检查 #jedis.pool.testOnReturn=true","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://builderqiu.com/tags/Redis/"},{"name":"在线列表","slug":"在线列表","permalink":"http://builderqiu.com/tags/在线列表/"},{"name":"SessionListener","slug":"SessionListener","permalink":"http://builderqiu.com/tags/SessionListener/"}]},{"title":"基于DFA的关键字过滤实现","slug":"KeywordFilterBaseOnDFA","date":"2014-05-24T16:00:00.000Z","updated":"2016-12-25T08:23:05.372Z","comments":true,"path":"2014/05/KeywordFilterBaseOnDFA.html","link":"","permalink":"http://builderqiu.com/2014/05/KeywordFilterBaseOnDFA.html","excerpt":"GISTS地址","text":"GISTS地址","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"DFA","slug":"DFA","permalink":"http://builderqiu.com/tags/DFA/"}]},{"title":"使用消息队列异步化系统","slug":"AsyncSystemByMQ","date":"2014-05-22T16:00:00.000Z","updated":"2016-12-25T08:21:48.907Z","comments":true,"path":"2014/05/AsyncSystemByMQ.html","link":"","permalink":"http://builderqiu.com/2014/05/AsyncSystemByMQ.html","excerpt":"基于Spring与ActiveMQ的配置实现方案 前言前期为了快速开发，项目结构较为混乱，代码维护与功能扩展都比较困难，为了方便后续功能开发，最近对项目进行的重构，顺便在重构的过程中将之前的部分操作进行了异步处理，也第一次实际接触了JMS与消息队列。项目中采用的消息中间件为ActiveMQ。","text":"基于Spring与ActiveMQ的配置实现方案 前言前期为了快速开发，项目结构较为混乱，代码维护与功能扩展都比较困难，为了方便后续功能开发，最近对项目进行的重构，顺便在重构的过程中将之前的部分操作进行了异步处理，也第一次实际接触了JMS与消息队列。项目中采用的消息中间件为ActiveMQ。 什么是JMSJava消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。 Java消息服务的规范包括两种消息模式，点对点和发布者／订阅者。许多提供商支持这一通用框架因此，程序员可以在他们的分布式软件中实现面向消息的操作，这些操作将具有不同面向消息中间件产品的可移植性。 Java消息服务支持同步和异步的消息处理，在某些场景下，异步消息是必要的；在其他场景下，异步消息比同步消息操作更加便利。 Java消息服务支持面向事件的方法接收消息，事件驱动的程序设计现在被广泛认为是一种富有成效的程序设计范例，程序员们都相当熟悉。 在应用系统开发时，Java消息服务可以推迟选择面对消息中间件产品，也可以在不同的面对消息中间件切换。——Wiki 什么是消息队列在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自使用者。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入装置的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 目前，有很多消息队列有很多开源的实现，包括JBoss Messaging、JORAM、Apache ActiveMQ、Sun Open Message Queue、Apache Qpid和HTTPSQS。 消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这和大多数通信协议是不同的。例如WWW中使用的HTTP协议是同步的，因为客户端在发出请求后必须等待服务器回应。然而，很多情况下我们需要异步的通信协议。比如，一个进程通知另一个进程发生了一个事件，但不需要等待回应。但消息队列的异步特点，也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。 和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据，这可以减少开发人员的工作量。但消息队列仍然有大小限制。——Wiki 使用消息队列的优点 正文基本类图结构如下： 类结构 说明： AsyncWork：消息的处理类接口，定义各类型的消息的处理方式 AsyncWorkProducer：消息的生产者（JMS生产者），负责向消息队列里面放入消息 AsyncWorkConsumer：消息的消费者（JMS消费者），负责从消息队列中消费消息 AsyncWorkFactory：对外提供的服务的工厂类 EmailWork、PushNotificationWork、LoginLogWork…：实现AsyncWork接口，定义消息的具体处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AsyncWorkProducer &#123; //ConnectionFactory ：连接工厂，JMS 用它创建连接 private ConnectionFactory connectionFactory; private String queueName = \"QueueName\"; public AsyncWorkProducer(String queueName)&#123; this.queueName = queueName; init(); &#125; private void init()&#123; connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, SystemConfiguration.getString(\"asyc.location\")); &#125; public void sendMessage(Message message)&#123; Connection connection = null; try &#123; // Connection ：JMS 客户端到JMS Provider 的连接 | 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar connection = connectionFactory.createConnection(); //启动 connection.start(); // Session： 一个发送或接收消息的线程 | 获取操作连接 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); // Destination ：消息的目的地;消息发送给谁. Destination destination = session.createQueue(queueName); // MessageProducer：消息发送者 |得到消息生成者【发送者】 MessageProducer producer = session.createProducer(destination); //设置不持久化，实际根据项目决定 producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); // 发送消息到目的地方 producer.send(message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; if (null != connection)&#123; connection.close(); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125;&#125; 服务工厂类，貌似作用不大： 123456789101112131415161718192021public class AsyncWorkFactory &#123; private static ConcurrentHashMap&lt;String, AsyncWorkProducer&gt; chm = new ConcurrentHashMap&lt;String, AsyncWorkProducer&gt;(); private AsyncWorkFactory()&#123;&#125; public static AsyncWorkProducer getProducer(String queueName)&#123; AsyncWorkProducer awp = chm.get(queueName); if(awp==null)&#123; awp = new AsyncWorkProducer(queueName); chm.put(queueName, awp); &#125; return awp; &#125; public static void sendMessage(Message message,String queueName)&#123; getProducer(queueName).sendMessage(message); &#125;&#125; 线程监听： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class AsyncWorkConsumer implements Runnable&#123; // ConnectionFactory ：连接工厂，JMS 用它创建连接 private ConnectionFactory connectionFactory; private AsycWork work; private String queueName = \"QueueName\"; public AsyncWorkConsumer(String queueName,AsycWork work)&#123; this.queueName = queueName; this.work = work; init(); &#125; private void init()&#123; connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, SystemConfiguration.getString(\"asyc.location\")); &#125; @Override public void run() &#123; Connection connection = null; try &#123; // Connection ：JMS 客户端到JMS Provider 的连接 | 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar connection = connectionFactory.createConnection(); connection.start(); // Session： 一个发送或接收消息的线程 | 获取操作连接 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); // Destination ：消息的目的地;消息发送给谁. Destination destination = session.createQueue(queueName); // MessageProducer：消息发送者 |得到消息生成者【发送者】 MessageConsumer consumer = session.createConsumer(destination); //设置不持久化，实际根据项目决定 while (true) &#123; //可设置接收者接收消息的时间 consumer.recevie(xxx) Message message = consumer.receive(); work.execute(message); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; if (null != connection)&#123; connection.close(); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125;&#125; 回调处理： 1234567891011121314151617181920public class EmailWorker implements AsycWork &#123; private static Logger log = LoggerFactory.getLogger(EmailWorker.class); @Override public void execute(Message message) &#123; ActiveMQMapMessage msg = (ActiveMQMapMessage) message; try &#123; String address = msg.getString(\"address\"); String title = msg.getString(\"title\"); String content = msg.getString(\"content\"); Constants.sendMail(address, title, content); &#125; catch (JMSException e) &#123; log.error(\"异步邮件发送异常\", e); &#125; &#125;&#125; 项目启动时执行如下代码启动线程： 123456789101112Thread emailThread = new Thread(new AsyncWorkConsumer(AsycWork.EMAIL,emailWorker));emailThread.setDaemon(true);emailThread.start();//启动线程绑定各种回调Thread normalLogThread = new Thread(new AsyncWorkConsumer(AsycWork.NORMAL_LOG,normalLogWork));normalLogThread.setDaemon(true);normalLogThread.start();Thread loginLogThread = new Thread(new AsyncWorkConsumer(AsycWork.LOGIN_LOG,loginLogWorker));loginLogThread.setDaemon(true);loginLogThread.start(); 调用异步的工具类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class AsyncUtils &#123; private static Logger log = LoggerFactory.getLogger(AsyncUtils.class); public static void log(String type,String operate)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_NORMAL_LOG))&#123; return; &#125; try&#123; User user = (User) SecurityUtils.getSubject().getSession().getAttribute(\"loginUser\"); if(user==null)&#123; return; &#125; OperateLog log = new OperateLog(user.getId(), user.getName(), operate,type, user.getLastLoginIp()); ActiveMQObjectMessage message = new ActiveMQObjectMessage(); message.setObject(log); AsyncWorkFactory.sendMessage(message, AsycWork.NORMAL_LOG); &#125;catch (Exception e) &#123; log.error(\"日志记录出错!\", e); &#125; &#125; public static void sendMail(String address,String title,String content)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_SEND_MAIL))&#123; return; &#125; try&#123; ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"address\", address); message.setString(\"title\", title); message.setString(\"content\", content); AsyncWorkFactory.sendMessage(message, AsycWork.EMAIL); &#125;catch (Exception e) &#123; log.error(\"邮件发送出错！\",e); &#125; &#125; public static void loginLog(String uid,String ip,Date date)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_LOG_CLIENTUSER_LOGINLOG))&#123; return; &#125; try&#123; ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"uid\", uid); message.setString(\"ip\", ip); message.setString(\"date\", DateUtils.formatDateTime(date, \"yyyy-MM-dd HH:mm:ss\")); AsyncWorkFactory.sendMessage(message, AsycWork.LOGIN_LOG); &#125;catch (Exception e) &#123; log.error(\"邮件发送出错！\",e); &#125; &#125;&#125; 在需要异步处理的地方执行类似如下代码： 1AsyncUtils.sendMail(\"xxx@xxx.com\", \"邮件标题\", \"邮件内容\");//异步发送邮件 这样就可以执行异步操作了。 适用于异步系统适用于与主要业务逻辑无关的较耗时或不需要同步操作的，失败时不影响主业务逻辑的功能点： 比如：1.在用户注册的时候记录数据做后期统计、发送注册成功邮件等 2.系统操作的日志记录 3.iOS消息推送 4.发送短信 … 在使用异步系统之前，用户注册与注册日志记录是在同一个事务完成的，用户注册失败则不会记录日志，但同时，日志记录发生异常也会引起用户注册失败，日志记录本身是与用户注册这个逻辑不相关的工作，在日志发生异常的时候不应该使用户注册失败。 在使用异步系统之后，用户注册逻辑执行结束后，调用异步的注册日志记录与异步的注册邮件发送功能即可，不用等待日志记录与邮件发送的返回，即可直接返回用户注册成功。将日志与邮件异步处理，既提高了响应速度也使逻辑更加严谨。在发生异常的时候，消息队列会将消息继续保留，留待后续处理。 PS：本文的实现方式大部分为自己摸索的，之前没有接触过类似的模块，所以有些地方都是按照自己的理解处理的，通用的异步系统是不是这种结构本人不是太了解，欢迎交流。后面会介绍一下最新的实现方式，修改为了基于Spring管理的异步系统，将ActiveMQ丢给了Spring，依靠Spring发送与监听消息，相比这个可能会更靠谱一点。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://builderqiu.com/tags/Spring/"},{"name":"Async","slug":"Async","permalink":"http://builderqiu.com/tags/Async/"}]},{"title":"使用消息队列异步化系统","slug":"AsyncSystem","date":"2014-05-22T16:00:00.000Z","updated":"2016-12-25T08:22:17.812Z","comments":true,"path":"2014/05/AsyncSystem.html","link":"","permalink":"http://builderqiu.com/2014/05/AsyncSystem.html","excerpt":"","text":"基于Spring与ActiveMQ的配置实现方案 前言前期为了快速开发，项目结构较为混乱，代码维护与功能扩展都比较困难，为了方便后续功能开发，最近对项目进行的重构，顺便在重构的过程中将之前的部分操作进行了异步处理，也第一次实际接触了JMS与消息队列。项目中采用的消息中间件为ActiveMQ。 什么是JMSJava消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。 Java消息服务的规范包括两种消息模式，点对点和发布者／订阅者。许多提供商支持这一通用框架因此，程序员可以在他们的分布式软件中实现面向消息的操作，这些操作将具有不同面向消息中间件产品的可移植性。 Java消息服务支持同步和异步的消息处理，在某些场景下，异步消息是必要的；在其他场景下，异步消息比同步消息操作更加便利。 Java消息服务支持面向事件的方法接收消息，事件驱动的程序设计现在被广泛认为是一种富有成效的程序设计范例，程序员们都相当熟悉。 在应用系统开发时，Java消息服务可以推迟选择面对消息中间件产品，也可以在不同的面对消息中间件切换。——Wiki 什么是消息队列在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自使用者。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入装置的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 目前，有很多消息队列有很多开源的实现，包括JBoss Messaging、JORAM、Apache ActiveMQ、Sun Open Message Queue、Apache Qpid和HTTPSQS。 消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这和大多数通信协议是不同的。例如WWW中使用的HTTP协议是同步的，因为客户端在发出请求后必须等待服务器回应。然而，很多情况下我们需要异步的通信协议。比如，一个进程通知另一个进程发生了一个事件，但不需要等待回应。但消息队列的异步特点，也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。 和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据，这可以减少开发人员的工作量。但消息队列仍然有大小限制。——Wiki 使用消息队列的优点 正文基本类图结构如下： 类结构 说明： AsyncWork：消息的处理类接口，定义各类型的消息的处理方式 AsyncWorkProducer：消息的生产者（JMS生产者），负责向消息队列里面放入消息 AsyncWorkConsumer：消息的消费者（JMS消费者），负责从消息队列中消费消息 AsyncWorkFactory：对外提供的服务的工厂类 EmailWork、PushNotificationWork、LoginLogWork…：实现AsyncWork接口，定义消息的具体处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AsyncWorkProducer &#123; //ConnectionFactory ：连接工厂，JMS 用它创建连接 private ConnectionFactory connectionFactory; private String queueName = \"QueueName\"; public AsyncWorkProducer(String queueName)&#123; this.queueName = queueName; init(); &#125; private void init()&#123; connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, SystemConfiguration.getString(\"asyc.location\")); &#125; public void sendMessage(Message message)&#123; Connection connection = null; try &#123; // Connection ：JMS 客户端到JMS Provider 的连接 | 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar connection = connectionFactory.createConnection(); //启动 connection.start(); // Session： 一个发送或接收消息的线程 | 获取操作连接 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); // Destination ：消息的目的地;消息发送给谁. Destination destination = session.createQueue(queueName); // MessageProducer：消息发送者 |得到消息生成者【发送者】 MessageProducer producer = session.createProducer(destination); //设置不持久化，实际根据项目决定 producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); // 发送消息到目的地方 producer.send(message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; if (null != connection)&#123; connection.close(); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125;&#125; 服务工厂类，貌似作用不大： 123456789101112131415161718192021public class AsyncWorkFactory &#123; private static ConcurrentHashMap&lt;String, AsyncWorkProducer&gt; chm = new ConcurrentHashMap&lt;String, AsyncWorkProducer&gt;(); private AsyncWorkFactory()&#123;&#125; public static AsyncWorkProducer getProducer(String queueName)&#123; AsyncWorkProducer awp = chm.get(queueName); if(awp==null)&#123; awp = new AsyncWorkProducer(queueName); chm.put(queueName, awp); &#125; return awp; &#125; public static void sendMessage(Message message,String queueName)&#123; getProducer(queueName).sendMessage(message); &#125;&#125; 线程监听： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class AsyncWorkConsumer implements Runnable&#123; // ConnectionFactory ：连接工厂，JMS 用它创建连接 private ConnectionFactory connectionFactory; private AsycWork work; private String queueName = \"QueueName\"; public AsyncWorkConsumer(String queueName,AsycWork work)&#123; this.queueName = queueName; this.work = work; init(); &#125; private void init()&#123; connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, SystemConfiguration.getString(\"asyc.location\")); &#125; @Override public void run() &#123; Connection connection = null; try &#123; // Connection ：JMS 客户端到JMS Provider 的连接 | 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar connection = connectionFactory.createConnection(); connection.start(); // Session： 一个发送或接收消息的线程 | 获取操作连接 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); // Destination ：消息的目的地;消息发送给谁. Destination destination = session.createQueue(queueName); // MessageProducer：消息发送者 |得到消息生成者【发送者】 MessageConsumer consumer = session.createConsumer(destination); //设置不持久化，实际根据项目决定 while (true) &#123; //可设置接收者接收消息的时间 consumer.recevie(xxx) Message message = consumer.receive(); work.execute(message); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; if (null != connection)&#123; connection.close(); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125;&#125; 回调处理： 1234567891011121314151617181920public class EmailWorker implements AsycWork &#123; private static Logger log = LoggerFactory.getLogger(EmailWorker.class); @Override public void execute(Message message) &#123; ActiveMQMapMessage msg = (ActiveMQMapMessage) message; try &#123; String address = msg.getString(\"address\"); String title = msg.getString(\"title\"); String content = msg.getString(\"content\"); Constants.sendMail(address, title, content); &#125; catch (JMSException e) &#123; log.error(\"异步邮件发送异常\", e); &#125; &#125;&#125; 项目启动时执行如下代码启动线程： 123456789101112Thread emailThread = new Thread(new AsyncWorkConsumer(AsycWork.EMAIL,emailWorker));emailThread.setDaemon(true);emailThread.start();//启动线程绑定各种回调Thread normalLogThread = new Thread(new AsyncWorkConsumer(AsycWork.NORMAL_LOG,normalLogWork));normalLogThread.setDaemon(true);normalLogThread.start();Thread loginLogThread = new Thread(new AsyncWorkConsumer(AsycWork.LOGIN_LOG,loginLogWorker));loginLogThread.setDaemon(true);loginLogThread.start(); 调用异步的工具类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class AsyncUtils &#123; private static Logger log = LoggerFactory.getLogger(AsyncUtils.class); public static void log(String type,String operate)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_NORMAL_LOG))&#123; return; &#125; try&#123; User user = (User) SecurityUtils.getSubject().getSession().getAttribute(\"loginUser\"); if(user==null)&#123; return; &#125; OperateLog log = new OperateLog(user.getId(), user.getName(), operate,type, user.getLastLoginIp()); ActiveMQObjectMessage message = new ActiveMQObjectMessage(); message.setObject(log); AsyncWorkFactory.sendMessage(message, AsycWork.NORMAL_LOG); &#125;catch (Exception e) &#123; log.error(\"日志记录出错!\", e); &#125; &#125; public static void sendMail(String address,String title,String content)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_SEND_MAIL))&#123; return; &#125; try&#123; ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"address\", address); message.setString(\"title\", title); message.setString(\"content\", content); AsyncWorkFactory.sendMessage(message, AsycWork.EMAIL); &#125;catch (Exception e) &#123; log.error(\"邮件发送出错！\",e); &#125; &#125; public static void loginLog(String uid,String ip,Date date)&#123; if(!SystemConfigFromDB.getBoolean(SystemConfigFromDB.NEED_LOG_CLIENTUSER_LOGINLOG))&#123; return; &#125; try&#123; ActiveMQMapMessage message = new ActiveMQMapMessage(); message.setString(\"uid\", uid); message.setString(\"ip\", ip); message.setString(\"date\", DateUtils.formatDateTime(date, \"yyyy-MM-dd HH:mm:ss\")); AsyncWorkFactory.sendMessage(message, AsycWork.LOGIN_LOG); &#125;catch (Exception e) &#123; log.error(\"邮件发送出错！\",e); &#125; &#125;&#125; 在需要异步处理的地方执行类似如下代码： 1AsyncUtils.sendMail(\"xxx@xxx.com\", \"邮件标题\", \"邮件内容\");//异步发送邮件 这样就可以执行异步操作了。 适用于异步系统适用于与主要业务逻辑无关的较耗时或不需要同步操作的，失败时不影响主业务逻辑的功能点： 比如：1.在用户注册的时候记录数据做后期统计、发送注册成功邮件等 2.系统操作的日志记录 3.iOS消息推送 4.发送短信 … 在使用异步系统之前，用户注册与注册日志记录是在同一个事务完成的，用户注册失败则不会记录日志，但同时，日志记录发生异常也会引起用户注册失败，日志记录本身是与用户注册这个逻辑不相关的工作，在日志发生异常的时候不应该使用户注册失败。 在使用异步系统之后，用户注册逻辑执行结束后，调用异步的注册日志记录与异步的注册邮件发送功能即可，不用等待日志记录与邮件发送的返回，即可直接返回用户注册成功。将日志与邮件异步处理，既提高了响应速度也使逻辑更加严谨。在发生异常的时候，消息队列会将消息继续保留，留待后续处理。 PS：本文的实现方式大部分为自己摸索的，之前没有接触过类似的模块，所以有些地方都是按照自己的理解处理的，通用的异步系统是不是这种结构本人不是太了解，欢迎交流。后面会介绍一下最新的实现方式，修改为了基于Spring管理的异步系统，将ActiveMQ丢给了Spring，依靠Spring发送与监听消息，相比这个可能会更靠谱一点。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[]},{"title":"基于Annotation与SpringAOP的缓存简单解决方案","slug":"MemcacheAnnotationBaseOnSpringAop","date":"2014-05-20T16:00:00.000Z","updated":"2016-12-25T08:23:12.098Z","comments":true,"path":"2014/05/MemcacheAnnotationBaseOnSpringAop.html","link":"","permalink":"http://builderqiu.com/2014/05/MemcacheAnnotationBaseOnSpringAop.html","excerpt":"前言： 由于项目的原因，需要对项目中大量访问多修改少的数据进行缓存并管理，为达到开发过程中通过Annotation简单的配置既可以完成对缓存的设置与更新的需求，故而设计的该简易的解决方案。","text":"前言： 由于项目的原因，需要对项目中大量访问多修改少的数据进行缓存并管理，为达到开发过程中通过Annotation简单的配置既可以完成对缓存的设置与更新的需求，故而设计的该简易的解决方案。 涉及技术： 1.Spring AOP 2.Java Annotation 3.Memcache （项目中使用的缓存组件） 4.JVM基础 （Class文件结构，用于解析出方法中的形参名称，动态生成缓存key，目测效率不高0.0） 5.Ognl （用于动态解析缓存的key） 实现细节： Annotation：LoadFromMemcached 用于method之上的注解，作用是使带有该注解的method在调用的时候先经过缓存查询，缓存中查询不到再去数据库查询并将结果缓存至缓存服务器Memcache中， 12345678910111213141516import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface LoadFromMemcached &#123; String value();//缓存的key int timeScope() default 600;//默认过期时间，单位秒 String condition() default \"\";//执行缓存查询的条件&#125; Annotation：UpdateForMemcached 类似于LoadFromMemcached，作用是使带有该注解的method在调用的时候更新缓存服务器中的缓存， 12345678910111213import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface UpdateForMemcached &#123; String[] value();//可能有多个key需要更新 String condition() default \"\";//执行缓存的条件&#125; AOP：MemcachedCacheInterceptor 缓存AOP实现的核心类，用于对Annotation注解了的method进行拦截并进行相应的操作， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.TimeoutException;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.annotation.Resource;import net.rubyeye.xmemcached.MemcachedClient;import net.rubyeye.xmemcached.exception.MemcachedException;import ognl.Ognl;import ognl.OgnlException;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;@Component@Aspectpublic class MemcachedCacheInterceptor &#123; private final String GET = \"@annotation(LoadFromMemcached)\"; private final String UPDATE = \"@annotation(UpdateForMemcached)\"; // 替换为其他缓存组件即可切换为其他缓存系统，这里是使用的Memcached。如果再抽象一层缓存系统管理，则可以动态的更换缓存系统。 @Resource private MemcachedClient cache; private Logger log = LoggerFactory .getLogger(MemcachedCacheInterceptor.class); /** * * @Title: get * @Description: 首先从缓存中加载数据，缓存命中则返回数据，未命中则从数据库查找，并加入缓存 * @param @param call * @param @return * @param @throws Throwable * @return Object * @throws */ @Around(GET) public Object get(ProceedingJoinPoint call) throws Throwable &#123; LoadFromMemcached anno = getAnnotation(call, LoadFromMemcached.class); String key = anno.value(); int timeSocpe = anno.timeScope(); if (!executeCondition(anno.condition(), call)) &#123;// 不满足条件,直接调用方法，不进行缓存AOP操作 return call.proceed(); &#125; key = getKeyNameFromParam(key, call); Object value = null; try &#123; value = cache.get(key); &#125; catch (TimeoutException e) &#123; log.error(\"Get Data From Memcached TimeOut!About Key:\" + key, e); e.printStackTrace(); &#125; catch (InterruptedException e) &#123; log.error( \"Get Data From Memcached TimeOut And Interrupted!About Key:\" + key, e); e.printStackTrace(); &#125; catch (MemcachedException e) &#123; log.error( \"Get Data From Memcached And Happend A Unexpected Error!About Key:\" + key, e); e.printStackTrace(); &#125; if (value == null) &#123; value = call.proceed(); if (value != null) &#123; try &#123; cache.add(key, timeSocpe, value); log.info(\"Add Data For Memcached Success!About Key:\" + key); &#125; catch (TimeoutException e) &#123; log.error( \"Add Data For Memcached TimeOut!About Key:\" + key, e); e.printStackTrace(); &#125; catch (InterruptedException e) &#123; log.error( \"Add Data For Memcached TimeOut And Interrupted!About Key:\" + key, e); e.printStackTrace(); &#125; catch (MemcachedException e) &#123; log.error( \"Add Data For Memcached And Happend A Unexpected Error!About Key:\" + key, e); e.printStackTrace(); &#125; &#125; &#125; return value; &#125; /** * * @Title: update * @Description: 执行方法的同时更新缓存中的数据 * @param @param call * @param @return * @param @throws Throwable * @return Object * @throws */ @Around(UPDATE) public Object update(ProceedingJoinPoint call) throws Throwable &#123; UpdateForMemcached anno = getAnnotation(call, UpdateForMemcached.class); String[] key = anno.value();// 可能需要更新多个key Object value = call.proceed(); if (!executeCondition(anno.condition(), call)) &#123;// 不满足条件,直接调用方法，不进行缓存AOP操作 return value; &#125; if (value != null) &#123; try &#123; for (String singleKey : key) &#123;// 循环处理所有需要更新的key String tempKey = getKeyNameFromParam(singleKey, call); cache.delete(tempKey); &#125; log.info(\"Update Data For Memcached Success!About Key:\" + key); &#125; catch (TimeoutException e) &#123; log.error(\"Update Data For Memcached TimeOut!About Key:\" + key, e); e.printStackTrace(); &#125; catch (InterruptedException e) &#123; log.error( \"Update Data For Memcached TimeOut And Interrupted!About Key:\" + key, e); e.printStackTrace(); &#125; catch (MemcachedException e) &#123; log.error( \"Update Data For Memcached And Happend A Unexpected Error!About Key:\" + key, e); e.printStackTrace(); &#125; &#125; return value; &#125; /** * * @Title: getAnnotation * @Description: 获得Annotation对象 * @param @param &lt;T&gt; * @param @param jp * @param @param clazz * @param @return * @return T * @throws */ private &lt;T extends Annotation&gt; T getAnnotation(ProceedingJoinPoint jp, Class&lt;T&gt; clazz) &#123; MethodSignature joinPointObject = (MethodSignature) jp.getSignature(); Method method = joinPointObject.getMethod(); return method.getAnnotation(clazz); &#125; /** * * @Title: getKeyNameFromParam * @Description: 获得组合后的KEY值 * @param @param key * @param @param jp * @param @return * @return String * @throws */ private String getKeyNameFromParam(String key, ProceedingJoinPoint jp) &#123; if (!key.contains(\"$\")) &#123; return key; &#125; String regexp = \"\\\\$\\\\&#123;[^\\\\&#125;]+\\\\&#125;\"; Pattern pattern = Pattern.compile(regexp); Matcher matcher = pattern.matcher(key); List&lt;String&gt; names = new ArrayList&lt;String&gt;(); try &#123; while (matcher.find()) &#123; names.add(matcher.group()); &#125; key = executeNames(key, names, jp); &#125; catch (Exception e) &#123; log.error(\"Regex Parse Error!\", e); &#125; return key; &#125; /** * * @Title: executeNames * @Description: 对KEY中的参数进行替换 * @param @param key * @param @param names * @param @param jp * @param @return * @param @throws OgnlException * @return String * @throws */ private String executeNames(String key, List&lt;String&gt; names, ProceedingJoinPoint jp) throws OgnlException &#123; Method method = ((MethodSignature) jp.getSignature()).getMethod(); // 形参列表 List&lt;String&gt; param = MethodParamNamesScaner.getParamNames(method); if (names == null || names.size() == 0) &#123; return key; &#125; Object[] params = jp.getArgs(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); for (int i = 0; i &lt; param.size(); i++) &#123; map.put(param.get(i), params[i]); &#125; for (String name : names) &#123; String temp = name.substring(2); temp = temp.substring(0, temp.length() - 1); key = myReplace(key, name, (String) Ognl.getValue(temp, map)); &#125; return key; &#125; /** * * @Title: myReplace * @Description: 不依赖Regex的替换，避免$符号、&#123;&#125;等在String.replaceAll方法中当做Regex处理时候的问题。 * @param @param src * @param @param from * @param @param to * @param @return * @return String * @throws */ private String myReplace(String src, String from, String to) &#123; int index = src.indexOf(from); if (index == -1) &#123; return src; &#125; return src.substring(0, index) + to + src.substring(index + from.length()); &#125; /** * * @Title: executeCondition * @Description: 判断是否需要进行缓存操作 * @param @param condition parm * @param @return * @return boolean true:需要 false：不需要 * @throws */ private boolean executeCondition(String condition, ProceedingJoinPoint jp) &#123; if (\"\".equals(condition)) &#123; return true; &#125; Method method = ((MethodSignature) jp.getSignature()).getMethod(); // 形参列表 List&lt;String&gt; param = MethodParamNamesScaner.getParamNames(method); if (param == null || param.size() == 0) &#123; return true; &#125; Object[] params = jp.getArgs(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); for (int i = 0; i &lt; param.size(); i++) &#123; map.put(param.get(i), params[i]); &#125; boolean returnVal = false; try &#123; returnVal = (Boolean) Ognl.getValue(condition, map); &#125; catch (OgnlException e) &#123; e.printStackTrace(); &#125; return returnVal; &#125; public void setCache(MemcachedClient cache) &#123; this.cache = cache; &#125;&#125; 辅助类：借用MethodParamNamesScaner类与Ognl结合完成对缓存key的动态解析功能， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292//引用至：https://gist.github.com/wendal/2011728，用于解析方法的形参名称import java.io.BufferedInputStream;import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 通过读取Class文件,获得方法形参名称列表 * * @author wendal(wendal1985@gmail.com) * */public class MethodParamNamesScaner &#123; /** * 获取Method的形参名称列表 * * @param method * 需要解析的方法 * @return 形参名称列表,如果没有调试信息,将返回null */ public static List&lt;String&gt; getParamNames(Method method) &#123; try &#123; int size = method.getParameterTypes().length; if (size == 0) return new ArrayList&lt;String&gt;(0); List&lt;String&gt; list = getParamNames(method.getDeclaringClass()).get( getKey(method)); if (list != null &amp;&amp; list.size() != size) return list.subList(0, size); return list; &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取Constructor的形参名称列表 * * @param constructor * 需要解析的构造函数 * @return 形参名称列表,如果没有调试信息,将返回null */ public static List&lt;String&gt; getParamNames(Constructor&lt;?&gt; constructor) &#123; try &#123; int size = constructor.getParameterTypes().length; if (size == 0) return new ArrayList&lt;String&gt;(0); List&lt;String&gt; list = getParamNames(constructor.getDeclaringClass()) .get(getKey(constructor)); if (list != null &amp;&amp; list.size() != size) return list.subList(0, size); return list; &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; // --------------------------------------------------------------------------------------------------- /** * 获取一个类的所有方法/构造方法的形参名称Map * * @param klass * 需要解析的类 * @return 所有方法/构造方法的形参名称Map * @throws IOException * 如果有任何IO异常,不应该有,如果是本地文件,那100%遇到bug了 */ public static Map&lt;String, List&lt;String&gt;&gt; getParamNames(Class&lt;?&gt; klass) throws IOException &#123; InputStream in = klass.getResourceAsStream(\"/\" + klass.getName().replace('.', '/') + \".class\"); return getParamNames(in); &#125; public static Map&lt;String, List&lt;String&gt;&gt; getParamNames(InputStream in) throws IOException &#123; DataInputStream dis = new DataInputStream(new BufferedInputStream(in)); Map&lt;String, List&lt;String&gt;&gt; names = new HashMap&lt;String, List&lt;String&gt;&gt;(); Map&lt;Integer, String&gt; strs = new HashMap&lt;Integer, String&gt;(); dis.skipBytes(4);// Magic dis.skipBytes(2);// 副版本号 dis.skipBytes(2);// 主版本号 // 读取常量池 int constant_pool_count = dis.readUnsignedShort(); for (int i = 0; i &lt; (constant_pool_count - 1); i++) &#123; byte flag = dis.readByte(); switch (flag) &#123; case 7:// CONSTANT_Class: dis.skipBytes(2); break; case 9:// CONSTANT_Fieldref: case 10:// CONSTANT_Methodref: case 11:// CONSTANT_InterfaceMethodref: dis.skipBytes(2); dis.skipBytes(2); break; case 8:// CONSTANT_String: dis.skipBytes(2); break; case 3:// CONSTANT_Integer: case 4:// CONSTANT_Float: dis.skipBytes(4); break; case 5:// CONSTANT_Long: case 6:// CONSTANT_Double: dis.skipBytes(8); i++;// 必须跳过一个,这是class文件设计的一个缺陷,历史遗留问题 break; case 12:// CONSTANT_NameAndType: dis.skipBytes(2); dis.skipBytes(2); break; case 1:// CONSTANT_Utf8: int len = dis.readUnsignedShort(); byte[] data = new byte[len]; dis.read(data); strs.put(i + 1, new String(data, \"UTF-8\"));// 必然是UTF8的 break; case 15:// CONSTANT_MethodHandle: dis.skipBytes(1); dis.skipBytes(2); break; case 16:// CONSTANT_MethodType: dis.skipBytes(2); break; case 18:// CONSTANT_InvokeDynamic: dis.skipBytes(2); dis.skipBytes(2); break; default: throw new RuntimeException(\"Impossible!! flag=\" + flag); &#125; &#125; dis.skipBytes(2);// 版本控制符 dis.skipBytes(2);// 类名 dis.skipBytes(2);// 超类 // 跳过接口定义 int interfaces_count = dis.readUnsignedShort(); dis.skipBytes(2 * interfaces_count);// 每个接口数据,是2个字节 // 跳过字段定义 int fields_count = dis.readUnsignedShort(); for (int i = 0; i &lt; fields_count; i++) &#123; dis.skipBytes(2); dis.skipBytes(2); dis.skipBytes(2); int attributes_count = dis.readUnsignedShort(); for (int j = 0; j &lt; attributes_count; j++) &#123; dis.skipBytes(2);// 跳过访问控制符 int attribute_length = dis.readInt(); dis.skipBytes(attribute_length); &#125; &#125; // 开始读取方法 int methods_count = dis.readUnsignedShort(); for (int i = 0; i &lt; methods_count; i++) &#123; dis.skipBytes(2); // 跳过访问控制符 String methodName = strs.get(dis.readUnsignedShort()); String descriptor = strs.get(dis.readUnsignedShort()); short attributes_count = dis.readShort(); for (int j = 0; j &lt; attributes_count; j++) &#123; String attrName = strs.get(dis.readUnsignedShort()); int attribute_length = dis.readInt(); if (\"Code\".equals(attrName)) &#123; // 形参只在Code属性中 dis.skipBytes(2); dis.skipBytes(2); int code_len = dis.readInt(); dis.skipBytes(code_len); // 跳过具体代码 int exception_table_length = dis.readUnsignedShort(); dis.skipBytes(8 * exception_table_length); // 跳过异常表 int code_attributes_count = dis.readUnsignedShort(); for (int k = 0; k &lt; code_attributes_count; k++) &#123; int str_index = dis.readUnsignedShort(); String codeAttrName = strs.get(str_index); int code_attribute_length = dis.readInt(); if (\"LocalVariableTable\".equals(codeAttrName)) &#123;// 形参在LocalVariableTable属性中 int local_variable_table_length = dis .readUnsignedShort(); List&lt;String&gt; varNames = new ArrayList&lt;String&gt;( local_variable_table_length); for (int l = 0; l &lt; local_variable_table_length; l++) &#123; dis.skipBytes(2); dis.skipBytes(2); String varName = strs.get(dis .readUnsignedShort()); dis.skipBytes(2); dis.skipBytes(2); if (!\"this\".equals(varName)) // 非静态方法,第一个参数是this varNames.add(varName); &#125; names.put(methodName + \",\" + descriptor, varNames); &#125; else dis.skipBytes(code_attribute_length); &#125; &#125; else dis.skipBytes(attribute_length); &#125; &#125; dis.close(); return names; &#125; /** * 传入Method或Constructor,获取getParamNames方法返回的Map所对应的key */ public static String getKey(Object obj) &#123; StringBuilder sb = new StringBuilder(); if (obj instanceof Method) &#123; sb.append(((Method) obj).getName()).append(','); getDescriptor(sb, (Method) obj); &#125; else if (obj instanceof Constructor) &#123; sb.append(\"&lt;init&gt;,\"); // 只有非静态构造方法才能用有方法参数的,而且通过反射API拿不到静态构造方法 getDescriptor(sb, (Constructor&lt;?&gt;) obj); &#125; else throw new RuntimeException(\"Not Method or Constructor!\"); return sb.toString(); &#125; public static void getDescriptor(StringBuilder sb, Method method) &#123; sb.append('('); for (Class&lt;?&gt; klass : method.getParameterTypes()) getDescriptor(sb, klass); sb.append(')'); getDescriptor(sb, method.getReturnType()); &#125; public static void getDescriptor(StringBuilder sb, Constructor&lt;?&gt; constructor) &#123; sb.append('('); for (Class&lt;?&gt; klass : constructor.getParameterTypes()) getDescriptor(sb, klass); sb.append(')'); sb.append('V'); &#125; /** 本方法来源于ow2的asm库的Type类 */ public static void getDescriptor(final StringBuilder buf, final Class&lt;?&gt; c) &#123; Class&lt;?&gt; d = c; while (true) &#123; if (d.isPrimitive()) &#123; char car; if (d == Integer.TYPE) &#123; car = 'I'; &#125; else if (d == Void.TYPE) &#123; car = 'V'; &#125; else if (d == Boolean.TYPE) &#123; car = 'Z'; &#125; else if (d == Byte.TYPE) &#123; car = 'B'; &#125; else if (d == Character.TYPE) &#123; car = 'C'; &#125; else if (d == Short.TYPE) &#123; car = 'S'; &#125; else if (d == Double.TYPE) &#123; car = 'D'; &#125; else if (d == Float.TYPE) &#123; car = 'F'; &#125; else /* if (d == Long.TYPE) */&#123; car = 'J'; &#125; buf.append(car); return; &#125; else if (d.isArray()) &#123; buf.append('['); d = d.getComponentType(); &#125; else &#123; buf.append('L'); String name = d.getName(); int len = name.length(); for (int i = 0; i &lt; len; ++i) &#123; char car = name.charAt(i); buf.append(car == '.' ? '/' : car); &#125; buf.append(';'); return; &#125; &#125; &#125;&#125; 使用案例：1.使用缓存：12345678910/* * value:缓存中的键，$&#123;map.name&#125;会动态替换为传入参数map里面的key为name的值。 * comdition：缓存执行条件：!map.containsKey('execute')表示map中不包含execute这个key的时候才进行缓存操作。 * 这里面的map是传入的参数名称。 * 执行到该方法会自动去缓存里面查找该key，有就直接返回，没有就执行该方法，如果返回值不为空则同时存入缓存并返回结果。 */@LoadFromMemcached(value=\"Resource_selectByMap_$&#123;map.name&#125;\",condition=\"!map.containsKey('execute')\" )public List&lt;Resource&gt; selectByMap(Object map) &#123; return super.selectByMap(map);&#125; 表示执行该method(selectByMap)的时候会首先去缓存组件中查找数据，如果查找到数据就直接返回，如果找不到数据就执行方法体，并将返回值记录入缓存中。 2.更新缓存：12345678/* * 同样value为缓存中的key，$&#123;t.name&#125;会动态替换为update方法传入参数Resource的name字段 * comdition：字段作用同上，不演示了 */@UpdateForMemcached(value=\"Resource_selectByMap_$&#123;t.name&#125;\")public int update(Resource t) &#123; return super.update(t);&#125; 表示执行该method(update)的时候会同步将缓存中的key置为过期(并不是把该方法的返回值放入缓存，只是将对应的缓存设为过期，下次再执行selectByMap的时候获取的就是最新的数据了)。 扩展：本文只是简单的解决方案，可能有很多不足的地方，欢迎交流，以此简单的结构为基础进行扩展，将MemcachedClient以及相关的缓存操作方法提取出来并完善细节即可完成基本通用的缓存组件。","categories":[{"name":"琢琢磨磨","slug":"琢琢磨磨","permalink":"http://builderqiu.com/categories/琢琢磨磨/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://builderqiu.com/tags/Spring/"},{"name":"Annotation","slug":"Annotation","permalink":"http://builderqiu.com/tags/Annotation/"}]},{"title":"在Servlet(或者Filter，或者Listener)中使用spring的IOC容器","slug":"UseSpringInServlet","date":"2014-05-20T16:00:00.000Z","updated":"2016-12-25T08:23:35.072Z","comments":true,"path":"2014/05/UseSpringInServlet.html","link":"","permalink":"http://builderqiu.com/2014/05/UseSpringInServlet.html","excerpt":"web.xml中的加载顺序为：listener &gt; filter &gt; servlet &gt; spring。其中filter的执行顺序是filter-mapping在web.xml中出现的先后顺序。加载顺序会影响对Spring bean的调用。比如filter需要用到bean ，但是加载顺序是先加载filter后加载Spring，则filter中初始化操作中的bean为null。所以，如果过滤器中要使用到 bean，可以将spring 的加载改成Listener的方式。","text":"web.xml中的加载顺序为：listener &gt; filter &gt; servlet &gt; spring。其中filter的执行顺序是filter-mapping在web.xml中出现的先后顺序。加载顺序会影响对Spring bean的调用。比如filter需要用到bean ，但是加载顺序是先加载filter后加载Spring，则filter中初始化操作中的bean为null。所以，如果过滤器中要使用到 bean，可以将spring 的加载改成Listener的方式。 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml”，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。 12345678910111213private static ApplicationContext ctx = null;public Object getBean(String name) &#123; if (ctx == null) &#123; ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(this.servletContext); &#125; return ctx.getBean(name);&#125;``` 在Servlet或者filter或者Listener中使用Spring的IOC容器的方法是：```javaWebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getSession().getServletContext()); 由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象： 1WebApplicationContext webApplicationContext = (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); 事实上WebApplicationContextUtils.getWebApplicationContext方法就是使用上面的代码实现的，建议使用上面上面的静态方法 注意：在使用webApplicationContext.getBean(“ServiceName”)的时候，前面强制转化要使用接口，如果使用实现类会报类型转换错误。如： 1UserService userService ＝ (UserService) webApplicationContext.getBean(\"userService\");","categories":[{"name":"他山之石","slug":"他山之石","permalink":"http://builderqiu.com/categories/他山之石/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://builderqiu.com/tags/Spring/"}]}]}